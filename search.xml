<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>CSS设计指南：定位元素(一)</title>
      <link href="/2018/09/23/CSS%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0(%E4%B8%80)/"/>
      <content type="html"><![CDATA[<p>CSS定位元素<br><a id="more"></a></p><h2 id="定位元素-一"><a href="#定位元素-一" class="headerlink" title="定位元素(一)"></a>定位元素(一)</h2><p><br></p><h3 id="一、-理解盒子模型"><a href="#一、-理解盒子模型" class="headerlink" title="一、 理解盒子模型"></a><strong>一、 理解盒子模型</strong></h3><blockquote><p>每一个元素都会在页面上生成一个盒子，HTML页面实际上就是由一堆盒子组成的，默认情况下，每个盒子的边框都不可见，背景也是透明的。</p></blockquote><p>那么，盒模型有哪些属性呢，总的来说盒子的属性可分为三组：</p><ul><li><strong>border（边框）</strong> 可以设置边框的宽窄、样式和颜色</li><li><strong>padding（内边距）</strong>可以设置盒子内容区与边框的间距</li><li><strong>margin（外边距）</strong>可以设置盒子与相邻元素的间距</li></ul><p>一个盒子模型如下图所示<br><img src="/2018/09/23/CSS定位元素(一)/1531904043318.png" alt="Alt text"></p><p><br></p><h4 id="1-盒子边框（border）"><a href="#1-盒子边框（border）" class="headerlink" title="1. 盒子边框（border）"></a><strong>1. 盒子边框（border）</strong></h4><p>盒子边框有 3 个相关属性</p><ul><li><strong>boder-width</strong> 可以使用 thin、medium、thick等文本值，也可以使用除百分比和负值之外的任何绝对值。</li><li><strong>border-style</strong> 有none、hidden、dotted<code>(虚线)</code>、dashed、solid、double<code>（双实线）</code>、groove、ridge、inset、outset<code>（这四个是边框的内凹外凹）</code>等值。</li><li><strong>border-color</strong> 可以使用包括 RGB 、HSL 在内的任意颜色值和关键字。</li></ul><p>其中boder-width 、border-style 的值在不同浏览器中的显示可能有所不同。</p><p>默认情况下，边框的三个属性值分别为：</p><ul><li>border-width : medium</li><li>border-style : none</li><li>border-color : black</li></ul><p>因此默认情况下不会显示盒子边框，开发中我们常常会临时设定盒子的边框，为了快速把盒子边框显示出来，我们可以应用这条规则<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123; border：solid 1px ; &#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-盒子的内边距-padding"><a href="#2-盒子的内边距-padding" class="headerlink" title="2. 盒子的内边距(padding)"></a><strong>2. 盒子的内边距(padding)</strong></h4><p><strong>内边距是盒子内容区与盒子边框之间的距离。</strong></p><p>这是没有加 padding 的 p 元素<br><img src="/2018/09/23/CSS定位元素(一)/1531905405176.png" alt="Alt text"></p><p>当我们给他加上 10px 的 padding 之后<br><img src="/2018/09/23/CSS定位元素(一)/1531905439854.png" alt="Alt text"></p><blockquote><p>注意，由于内边距在盒子的内部，所以padding也会取得盒子的背景<br>仔细两幅图可以发现，内边距实际加在了声明的盒子的宽度之上（后面解释）</p></blockquote><p><br></p><h4 id="3-盒子的外边距-margin"><a href="#3-盒子的外边距-margin" class="headerlink" title="3. 盒子的外边距(margin)"></a><strong>3. 盒子的外边距(margin)</strong></h4><p>我们举三组标题和段落来说明盒子的外边距</p><p><img src="/2018/09/23/CSS定位元素(一)/1531905920851.png" alt="Alt text"></p><p>第一组和第二组都使用默认的样式，而第二组跟第一组的区别就是多了边框，对比之后，我们可以看到浏览器给标题和段落都设定了默认的 margin 样式。第三组我设定了 margin : 0 ，可以看到该组的标题和段落全部紧挨在一起。<br>因此，建议大家在写网页的时候，把这条规则作为样式表的第一条规则:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这个也叫<strong>重置CSS样式</strong>，作用是为了将浏览器给元素添加的默认样式都清除。网上有很多重置样式表（如 reset.css），还对很多元素在跨浏览器显示时的外观进行了标准化，想了解更多可以自行百度“CSS重置”</p></blockquote><p>关于外边距需要注意的几点</p><ul><li><strong>垂直外边距会叠加</strong></li></ul><p>假设有三个段落，我们均设定<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">margin-top</span>:<span class="number">50px</span>; <span class="attribute">margin-bottom</span>:<span class="number">3</span>opx;&#125;</span><br></pre></td></tr></table></figure></p><p>你可能会认为每两个段落之间的间距是 50 + 30 = 80px ，这种认知错误的，实际上他们之间的间距是50px！</p><p><strong>像这样上下外边距相遇时，它们就会相互重叠，直至一个外边距碰到另一个元素的边框</strong>，第二段较宽的上外边距会碰到第一段的边框，<strong>也就是说，较宽的外边距决 定两个元素终离多远</strong>，这就叫做外边距的叠加。</p><p><strong>注意，只有垂直外边距会叠加，水平外边距并不会叠加。</strong>对于水平相邻的元素他们的水平间距是相邻外边距之和。<br><br></p><ul><li><strong>外边距的单位</strong></li></ul><blockquote><p>根据经验，为文本元素设置外边距时通常需要混合使用不同的单位。<br>比如说，一个段落的左、右外边距可以使用像素，以便该段文本始终与包含元素边界保持固定间 距，不受字号变大或变小的影响。而<strong>对于上、下外边距，以 em为单位则可以让段间 距随字号变化而相应增大或缩小。</strong></p></blockquote><p>比如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里使用了简写属性把上、下外边距设置为.75em，把左、右外边距设置为 30 像素*/</span> </span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">1em</span>; <span class="attribute">margin</span>:.<span class="number">75em</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure></p><p>这样，段落的垂直间距始终会保持为字体高度的四分之三（上下外边距都是.75em， 叠加后还是.75em）。如果用户增大了字号，那么不仅段落中的文本会变大，段间距也会成比例变大。这样，页面的整体布局就会比较协调一致。与此同时，使用像素 单位的左、右外边距不会改变。</p><hr><p><br></p><h3 id="二、-盒子的大小是如何变化的"><a href="#二、-盒子的大小是如何变化的" class="headerlink" title="二、 盒子的大小是如何变化的"></a><strong>二、 盒子的大小是如何变化的</strong></h3><p>接下来我们用两种盒子来说明盒子的具体大小是如何变化的。</p><ul><li><strong>一种是没有宽度的盒子</strong>，既没有设定 width 属性。</li><li><strong>另一种是带有宽度的盒子</strong>，我们设定 width ：400px<br><br></li></ul><h4 id="1-没有宽度的盒子"><a href="#1-没有宽度的盒子" class="headerlink" title="1. 没有宽度的盒子"></a><strong>1. 没有宽度的盒子</strong></h4><p>没有设定 width 属性的块级元素盒子，他的 width 属性默认值是 auto ，结果会让元素的宽度扩展到父元素同宽。<br>接下来我们给一个段落添加以下样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>:helvetica, arial, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">1em</span>; <span class="attribute">margin</span>:<span class="number">0px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#caebff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br><img src="/2018/09/23/CSS定位元素(一)/1531907921945.png" alt="Alt text"></p><p>可以看到，段落文本扩展到了body元素同宽。<br>接下来，我们给文本左右两侧添加内边距 padding：0 20px;<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531908385632.png" class="lazyload"></p><p>可以看到，添加了内边距之后，文本块的宽度会减少。<br>接下来，我们给文本左右两侧添加边框 border-width：0 6px 0 6px;<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531908426749.png" class="lazyload"></p><p>虽然不太明显，但实际上文本块的宽度又减少了。<br>最后，我们给左右两侧再加上外边距 margin：0 30px;<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531908625311.png" class="lazyload"></p><p>果不其然，文本块的宽度再一次减少</p><p>结论：</p><blockquote><p><strong>没有（就是没有设置 width 的）宽度的元素始终会扩展到填满其父元素的宽度为止。</strong>添加水平边框、内边距和外边距，会导致内容宽度减少，<strong>减少量等于水平边框、内边距和外边距的和</strong>。</p></blockquote><p><br></p><h4 id="2-带有宽度的盒子"><a href="#2-带有宽度的盒子" class="headerlink" title="2. 带有宽度的盒子"></a><strong>2. 带有宽度的盒子</strong></h4><p>我们再用和上面没有宽度的盒子一样的方法，来看看带有宽度的盒子的大小是怎样变化的。<br>给段落添加样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">ont-family</span>:helvetica, arial, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">1em</span>; <span class="attribute">margin</span>:<span class="number">0px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#caebff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">400px</span>; <span class="comment">/* 设定元素宽度为400px*/</span></span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/placeholder.png" alt="Alt text" data-src="./1531909206438.png" class="lazyload"></p><p>可以看到，明确设定 width 属性后，块级元素就不会再扩展到与父元素（即 body）同宽了。<br>一样的，我们添加 20px 的内边距<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531909251064.png" class="lazyload"></p><p><strong>这一次，文本块的的宽度并由变化，反而使的元素比原来宽了 40px</strong><br>一样的，我们再给元素添加 6px 的边框</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="./1531909406049.png" class="lazyload"></p><p>最后，添加外边距</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="./1531909487051.png" class="lazyload"></p><p>为此我们可以得出，带有宽度的盒子模型大小变化的结论：</p><blockquote><p>为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展得更宽。实际上，盒子的 width 属性设定的只是盒子内容区的宽度，而非盒子要占据的水平宽度。</p></blockquote><p>总之，关于盒子大小的变化，我们需要记住一点<br><strong>设定了元素的 width 属性后，再给元素添加边框、内边距和 外边距，元素的行为与默认的 auto 状态下会有截然不同的表现。</strong> </p><hr><p><br></p><h3 id="三、-浮动与清除-float-clear"><a href="#三、-浮动与清除-float-clear" class="headerlink" title="三、 浮动与清除(float clear)"></a><strong>三、 浮动与清除(float clear)</strong></h3><p><br></p><h4 id="1-浮动"><a href="#1-浮动" class="headerlink" title="1. 浮动"></a><strong>1. 浮动</strong></h4><p><strong>浮动，意思就是把元素从常规文档流中拿出来。</strong><br>当你浮动一个元素的时候……这个元素就好像在说：‘尽量把我往上放，能放多高放多高，直到碰到某个元素的边界为止。</p><p>浮动元素脱离了常规文档流之后，原来紧跟其后的元素就会在空间允许的情况下，向上提升到与浮动元素平起平坐。</p><blockquote><p>CSS 设计 float 属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属性也成了<strong>创建多栏布局简单的方式</strong>。</p></blockquote><p>让我们先从文本绕排图片这个例子来认识浮动吧！</p><p><strong>文本绕排图片</strong></p><p>示例代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">img&#123;</span></span><br><span class="line"><span class="undefined">margin: 0 4px 4px 0;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">p&#123;</span></span><br><span class="line"><span class="undefined">margin: 0;</span></span><br><span class="line"><span class="undefined">border: solid 1px red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"pic03.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>原始效果<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532009409141.png" class="lazyload"></p><p>可以看到处在常规文档流中的图片跟段落这两个块级元素竖直排列在一起。</p><p>接下来，我们要实现文字绕排文字效果了，怎么做呢？</p><p>就是让图片浮动起来，我们给图片添加以下样式 img { float:left }<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532009670827.png" class="lazyload"></p><p>解释：</p><blockquote><p>在你浮动一张图片或者其他元素时，你是在要求浏览器把它往上方推，直到它碰到父元素（也就是 body 元素）的内边界。<strong>后面的段落（带灰色边框） 不再认为浮动元素在文档流中位于它的前面了，因而它会占据父元素左上角的位置。</strong> 不过，它的内容（文本）会绕开浮动的图片。 </p></blockquote><p>注意：</p><blockquote><p>由于图片自身带有宽度，因此在浮动的时候无需设定宽度。然而在浮动非图片元素时，必须给非图片元素设定宽度，否则后果难以预料<br><br></p></blockquote><h4 id="2-围住浮动元素的三种方法"><a href="#2-围住浮动元素的三种方法" class="headerlink" title="2. 围住浮动元素的三种方法"></a><strong>2. 围住浮动元素的三种方法</strong></h4><p>上面我们讲到，当一个元素浮动后，他就脱离了文档流，因而它也不被包含在父元素之内了，因此它也可能会对布局产生破坏性的影响。那么，我们该怎么控制浮动的元素呢？</p><p>接下来介绍把浮动元素“控制住”的三种方法</p><p>示例代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">section &#123;</span></span><br><span class="line"><span class="undefined">margin: 0 0 10px 0;</span></span><br><span class="line"><span class="undefined">border: solid 1px red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">p &#123;</span></span><br><span class="line"><span class="undefined">margin: 0;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">footer&#123;</span></span><br><span class="line"><span class="undefined">border: solid 1px red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"pic03.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>It's fun to float<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet....<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>原始效果<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532010675831.png" class="lazyload"></p><p>现在，一切正常，所有元素自上而下堆叠在一起，接下来，我们让图片标题位于图片右侧，该怎么做呢？从上一节我们知道，就是让图片浮动起来。给图片添加 img { float: left}</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="./1532010876833.png" class="lazyload"></p><p>OK，现在图片标题以及在图片右侧啦。</p><p>但是我们也看到，<strong>由于图片浮动了，现在图片已经不在父元素section里面了，换句话说，图片脱离了常规文档流，这也就导致了父元素section收缩到了只包含文本高度的高度。</strong> 而且，footer元素也被提上来了，紧挨着前一个块级元素，这可不是我们想要的。</p><p>所以，我们必须得把浮动元素“控制住”。<br><br></p><h5 id="方法一：给浮动元素的父元素添加-overflow：hidden"><a href="#方法一：给浮动元素的父元素添加-overflow：hidden" class="headerlink" title="方法一：给浮动元素的父元素添加 overflow：hidden"></a><strong>方法一：给浮动元素的父元素添加 overflow：hidden</strong></h5><pre><code>overflow：hidden的用途&gt; overflow:hidden 原本是使包含元素依然保持其设定的宽度，而超过的子内容则会被容器剪切掉（不被显示），防止包含元素被超大内容撑大。&gt; **除此之外，overflow:hidden 还有另一个作用，即它能可靠地迫使父元素包含其浮动的子元素。**</code></pre><p>现在我们试试给父元素 section 加上overflow : hidden<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532011483647.png" class="lazyload"></p><p>确认过眼神，是我们想要的效果！footer回到了我们期望的位置<br><br></p><h5 id="方法二：同时浮动父元素"><a href="#方法二：同时浮动父元素" class="headerlink" title="方法二：同时浮动父元素"></a><strong>方法二：同时浮动父元素</strong></h5><p>促使父元素包围其浮动子元素的方法，是也让父元素也浮动起来。<br>来，我们先试试给 section 添加float：left，让父元素浮动起来</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="./1532011822780.png" class="lazyload"></p><p>结果跟我们想象中的不太一样呢，别急，回想一下我们之前的知识点，在浮动非图片元素时，我们得给他们加一个宽度对吧。那么，为什么呢？</p><p><strong>原因是，当我们浮动任何元素时，不管其是否有子元素，不管其子元素是否浮动，他都会紧紧地包裹住它的内容，或者是，它的子元素。</strong></p><p>那就好解决了，我们给 section 加一个宽度width：100%，让它和浏览器同宽就好了。<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532012223208.png" class="lazyload"></p><p>这效果是对了，但怎么看起来总觉得怪怪的呢？原来是footer给挤上去了！</p><p>再回想一下，当我们浮动了一个元素，原本紧跟其后的元素也会在空间允许的情况下不断地往上挤。因此，footer 也无一例外地努力挤到了 section 的旁边了。</p><p>那么，我们该怎样使得 footer 依然呆在 section 下方呢？<br>答案是给footer应用一个清除 clear：left ，这样被清除的元素就不会被提升到浮动元素的旁边。<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532012933309.png" class="lazyload"></p><p><br></p><h5 id="方法三：给父元素添加-clearfix-after-规则"><a href="#方法三：给父元素添加-clearfix-after-规则" class="headerlink" title="方法三：给父元素添加 .clearfix:after 规则"></a><strong>方法三：给父元素添加 .clearfix:after 规则</strong></h5><p>.clearfix:after 规则：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">"."</span>;</span><br><span class="line"><span class="attribute">display</span>:block;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">visibility</span>:hidden;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>说明：</p><blockquote><p>这个 .clearfix 规则只添加了一个清除的包含句点作为非浮动元素（必须得有内容，而句点是最小的内容）。规则中的其他声明是 为了确保这个伪元素没有高度，而且在页面上不可见。<br>使用 clear:both 意味着 section 中新增的子元素会清除左、右浮动元素（位于左、右浮 动元素下方）。这里当然可以只用 left，但 both 也适用于将来图片 float:right 的情况。</p></blockquote><p>给section元素添加类 class=”clearfix” ，我们可以得到跟上图一样的效果<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532012933309.png" class="lazyload"><br><br></p><h5 id="三种方法如何选择？"><a href="#三种方法如何选择？" class="headerlink" title="三种方法如何选择？"></a><strong>三种方法如何选择？</strong></h5><p>这三种方法的使用要因地制宜。</p><blockquote><p>比如，不能在下拉菜单的顶级元素上应用 overflow:hidden，否则作为其子元素的下拉菜单就不会显示了。因为下拉菜单会显示在其父元素区域的外部，而这恰恰是 overflow:hidden 所要阻止的。</p></blockquote><blockquote><p>再比如，不能对已经靠自动外边距居中的元素使用“浮动父元素”技术，否则它就不会再居中，而是根据浮动值浮动到左边或右边了。</p></blockquote><blockquote><p>推荐使用clearfix规则</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>CSS设计指南：CSS选择器(二)</title>
      <link href="/2018/09/23/CSS%E9%80%89%E6%8B%A9%E5%99%A8(%E4%BA%8C)/"/>
      <content type="html"><![CDATA[<p>常用的CSS选择器(二)<br><a id="more"></a></p><h2 id="CSS选择器-二"><a href="#CSS选择器-二" class="headerlink" title="CSS选择器(二)"></a><strong>CSS选择器(二)</strong></h2><p><br></p><h3 id="4-属性名、属性值选择符"><a href="#4-属性名、属性值选择符" class="headerlink" title="4. 属性名、属性值选择符"></a>4. 属性名、属性值选择符</h3><p>所用示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">"yellow flower"</span> <span class="attr">alt</span>=<span class="string">"yellow flower"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">"blue flower"</span> <span class="attr">alt</span>=<span class="string">"blue flower"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1 . 属性名选择符</strong><br>用法：<strong>标签[属性名] { 声明 }</strong><br>例如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[title]</span> &#123;<span class="attribute">border</span>:<span class="number">3px</span> solid yellow;&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/23/CSS选择器(二)/1531730591644.png" alt="Alt text"></p><p><strong>2 . 属性值选择符</strong><br>用法： <strong>标签[属性名=”属性值”] {声明}</strong><br>例如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[title="red flower"]</span> &#123;<span class="attribute">border</span>:<span class="number">3px</span> solid blue;&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/23/CSS选择器(二)/1531730739166.png" alt="Alt text"></p><hr><p><br></p><h3 id="5-伪类"><a href="#5-伪类" class="headerlink" title="5. 伪类"></a>5. <strong>伪类</strong></h3><p>伪类这个叫法源自它们与类相似，但实际上并没有类会附加到标记中的标签上。伪类分两种。 </p><ul><li><strong>UI伪类</strong> 会在 HTML元素处于某个状态时（比如鼠标 指针位于链接上），为该元素应用 CSS样式。</li><li><strong>结构化伪类</strong> 会在标记中存在某种结构上的关系时（如某个元素是一组元素中的第 一个或后一个），为相应元素应用 CSS 样式。 </li></ul><p><br></p><h4 id="一-UI伪类"><a href="#一-UI伪类" class="headerlink" title="(一) UI伪类"></a><strong>(一) UI伪类</strong></h4><h5 id="1-链接伪类"><a href="#1-链接伪类" class="headerlink" title="1. 链接伪类"></a>1. 链接伪类</h5><ul><li><strong>:link</strong>      链接的默认状态</li><li><strong>:visited</strong>   用户点击过链接后的状态</li><li><strong>:hover</strong>     用户鼠标悬停在链接上的状态</li><li><strong>:active</strong>    链接正在被点击（鼠标还未释放）</li></ul><blockquote><p>如果不按上述顺序使用(不用四个全部使用)，浏览器可能不会显示预期的效果。<br>hover可以用于任何元素</p></blockquote><h5 id="2-focus-伪类"><a href="#2-focus-伪类" class="headerlink" title="2. : focus 伪类"></a>2. : focus 伪类</h5><p>表单中的文本字段在用户单击它时会获得焦点，然后用户才能在其中输入字符。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;</span><br></pre></td></tr></table></figure><p>上面的例子会在光标位于 input 字段中时，为该字段添加一个红色边框。</p><p><img src="/2018/09/23/CSS选择器(二)/1531732737935.png" alt="Alt text"></p><h5 id="3-target-伪类"><a href="#3-target-伪类" class="headerlink" title="3. : target 伪类"></a>3. : target 伪类</h5><p>如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标（target），可以 用:target 伪类选中它</p><p>例如<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#more_info"</span>&gt;</span>More Information<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"more_info"</span>&gt;</span>This is the information you are looking for.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用 : target之后<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#more_info</span><span class="selector-pseudo">:target</span>&#123;<span class="attribute">background</span>:<span class="number">#eee</span>;&#125;</span><br></pre></td></tr></table></figure></p><p>则用户点击链接后，h2的背景颜色将会变灰。<br><img src="/2018/09/23/CSS选择器(二)/1531733276477.png" alt="Alt text"></p><p><br></p><h4 id="（二）结构化伪类"><a href="#（二）结构化伪类" class="headerlink" title="（二）结构化伪类"></a><strong>（二）结构化伪类</strong></h4><p>结构化伪类可以根据标记的结构应用样式，比如根据某元素的父元素或前面的同胞 元素是什么。 常用的结构化伪类有这几种:</p><ul><li><strong>: first-child</strong>  代表一组同胞元素中的第一个元素</li><li><strong>: last-child</strong>  代表一组同胞元素中的最后一个元素</li><li><strong>: nth-child(n)</strong> <strong>n 表示一个数值(可用odd或even)</strong>，假如<strong>:nth-child(3)</strong>，表示选中一组同胞元素中的第三个元素</li></ul><p>例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line"><span class="selector-class">.results</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span>&#123;<span class="attribute">color</span>: blue&#125;</span><br><span class="line"><span class="selector-class">.results</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;<span class="attribute">color</span>: red&#125;</span><br><span class="line"><span class="selector-class">.results</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span>&#123;<span class="attribute">color</span>: yellow&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;ol class="results"&gt;</span><br><span class="line">&lt;li&gt;My Fast Pony&lt;/li&gt;     </span><br><span class="line">&lt;li&gt;Steady Trotter&lt;/li&gt;     </span><br><span class="line">&lt;li&gt;Slow Ol' Nag&lt;/li&gt; </span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/23/CSS选择器(二)/1531734412057.png" alt="Alt text"><br>tips：</p><ul><li>一个冒号（:）表示伪类，两个冒号（::）表示 CSS3新增的伪元素。</li><li>要习惯用双冒号代替单冒号，因为这些单冒号的伪元素终可能都会被淘汰掉。</li></ul><p><br></p><h4 id="（三）伪元素"><a href="#（三）伪元素" class="headerlink" title="（三）伪元素"></a><strong>（三）伪元素</strong></h4><p>常用伪元素</p><ul><li><p>:: first-letter</p><pre><code>可以选中段落首字符，可以用来创建首字符放大效果如：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span>&#123;<span class="attribute">font-size</span>:<span class="number">300%</span>&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>::first-line</p><pre><code>可以选中段落首行如：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span>&#123;<span class="attribute">font-variant</span>:small-caps&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>::before和::after</p><pre><code>可以在特定元素前面或后面添加特殊内容，例如：</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.age</span><span class="selector-pseudo">::before</span>&#123;<span class="attribute">content</span>: <span class="string">"Age"</span>&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.age</span><span class="selector-pseudo">::after</span>&#123;<span class="attribute">content</span>: <span class="string">"years."</span>&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p class="age"&gt;25&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/placeholder.png" alt="Alt text" data-src="./1531736054788.png" class="lazyload"></p><hr><p><br></p><h3 id="6-继承"><a href="#6-继承" class="headerlink" title="6. 继承"></a><strong>6. 继承</strong></h3><blockquote><p>在CSS中，祖先元素会向后代元素传递其CSS属性的值，这叫做CSS的继承。</p></blockquote><p>比如我们为body写一条规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>:helvetica, arial, sans-serif;&#125;</span><br></pre></td></tr></table></figure><p><strong>那么文档中的所有元素，无论层次结构多么靠下，都将继承body的样式。</strong></p><p>继承的给我们带来的效率是显而易见的。假如我们需要把网站的主字体或某个区域的主字体设置为微软雅黑，那么我们只需要在某个上层元素上指定font-family，而无须在每一个标签上都指定一次。<br>不过继承需要注意的几点：</p><ul><li><p>CSS很多属性（如文本颜色、字体、字号等）是可以继承的，也有很多属性是不能继承的，如涉及元素盒子的定位和显示方式，比如边框，内边距等，因为继承这些属性没有意义。</p></li><li><p>在使用相对字体单位时要小心，加入某个标签字体大小被设置为 80% ，他的后代字体大小也设置为 80% ，那么该后代的字体大小将会变成 64% ，即 80% 的 80% 。</p></li></ul><hr><p><br></p><h3 id="7-层叠"><a href="#7-层叠" class="headerlink" title="7. 层叠"></a><strong>7. 层叠</strong></h3><blockquote><p>层叠，就是层叠样式表中的层叠， 是一种样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性 值的多个来源，确定终使用哪个值。<br><br></p></blockquote><h4 id="样式来源"><a href="#样式来源" class="headerlink" title="样式来源"></a><strong>样式来源</strong></h4><p>一个网页的样式有多出来源，总的来说分为三种</p><ul><li><p><strong>浏览器的默认样式表</strong><br>浏览器自带的一些样式，比如h1的粗体，em的斜体，列表的项目符号和编号</p></li><li><p><strong>用户样式表</strong><br>用户(浏览网页的人)可以提供样式表，并不多见</p></li><li><p><strong>网页设计师（自己）的样式表</strong><br>即自己写的样式表，应用方式有 链接样式、嵌入样式、行内样式。</p></li></ul><p>有这么多种样式来源，浏览器如何选择按照那种样式表渲染网页呢？答案是，浏览器会按照下述顺序依次检查每个来源的样式。</p><ul><li><strong>浏览器默认样式表</strong></li><li><strong>用户样式表</strong></li><li><strong>链接式样式表</strong></li><li><strong>嵌入式样式</strong></li><li><strong>行内式样式</strong></li></ul><blockquote><p>举例个例子，假如链接样式表将 p 的字体设定为 Helvetica ，而页面中有一条嵌入样式将 p 的字体设定为微软雅黑，那么 p 最终会以微软雅黑字体显示。</p></blockquote><p>可以理解为样式来源的优先级为 <strong>行内 &gt; 嵌入 &gt; 链接 &gt; 用户 &gt; 浏览器</strong><br><br></p><h4 id="层叠规则"><a href="#层叠规则" class="headerlink" title="层叠规则"></a><strong>层叠规则</strong></h4><p><br></p><p><strong>层叠规则一：按照顺序和权重排序</strong></p><blockquote><p>浏览器一次检查 5 个样式来源，并设定匹配属性，如果匹配的属性在下一个来源也有定义，则更新该属性的值，如此循环。<br>声明也可以有权重。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:green <span class="meta">!important</span>; <span class="attribute">font-size</span>:<span class="number">12pt</span>; &#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><code>!important;</code>  用于加重声明的权重，不过比较一般少用，甚至不用。<br>上述代码的意思是，最终的颜色值还是绿色，其他来源一概不考虑，相当于一种特权。</p><p><br></p><p><strong>层叠规则二：按特指度排序</strong></p><p><strong>什么是特指度?</strong><br>特指度的意思是表示一条规则有多明确，例如：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-size</span>: <span class="number">12px</span>; &#125; </span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.largetext</span> &#123; <span class="attribute">font-size</span>:<span class="number">16px</span>; &#125;</span><br><span class="line">&lt;p class="largetext"&gt;A bit of text&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>结果 p 将会应用第二条规则，即显示 16px 的文本。因为第二条规则的选择符既有标签名又有类名，所以更加明确（特指度更高），因此第二条规则会覆盖第一条规则中的同名属性。</p><p><strong>如何计算特指度？</strong></p><p>采用  <strong>I - C- E</strong>  <code>(I指ID，C指class，E指Element)</code> 计算规则。</p><blockquote><ol><li>选择符中有一个 ID，就在 I的位置上加 1</li><li>选择符中有一个类，就在 C的位置上加 1</li><li>选择符中有一个元素（标签）名，就在 E的位置上加 1</li><li>得到一个三位数</li></ol></blockquote><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p0-0-1 特指度=1</span><br><span class="line">p.largetext 0-1-1 特指度=11     </span><br><span class="line">p#largetext 1-0-1 特指度=101</span><br><span class="line">body p#largetext 1-0-2 特指度=102</span><br><span class="line">body p#largetext ul.mylist 1-1-3 特指度=113</span><br><span class="line">body p#largetext ul.mylist li 1-1-4 特指度=114</span><br></pre></td></tr></table></figure></p><p><br></p><p> <strong>层叠规则三：顺序决定权重。</strong></p><blockquote><p>如果两条规则都影响某元素的同一个属性，而且它们的特指度也相同，则<strong>位置靠下（或后声明）的规则胜出</strong></p></blockquote><p>简单版<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531825917096.png" class="lazyload"></p><hr><h3 id="8-规则声明"><a href="#8-规则声明" class="headerlink" title="8. 规则声明"></a><strong>8. 规则声明</strong></h3><p>(待整理)</p><hr>]]></content>
      
      
    </entry>
    
    <entry>
      <title>CSS设计指南：CSS选择器(一)</title>
      <link href="/2018/09/02/CSS%E9%80%89%E6%8B%A9%E5%99%A8(%E4%B8%80)/"/>
      <content type="html"><![CDATA[<p>常用的css选择器(一)<br><a id="more"></a></p><h2 id="CSS选择器-一"><a href="#CSS选择器-一" class="headerlink" title="CSS选择器(一)"></a><strong>CSS选择器(一)</strong></h2><p><br></p><h3 id="1-1、上下文选择器"><a href="#1-1、上下文选择器" class="headerlink" title="1.1、上下文选择器"></a><strong>1.1、上下文选择器</strong></h3><p>上下文选择器的声明格式如下：</p><p><strong>标签1 标签2 { 声明 }</strong></p><blockquote><p>一组以空格分隔的标签名。用于选择作为指定祖先元素后代的标签。</p></blockquote><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>:bold; &#125;</span><br></pre></td></tr></table></figure><p>表示只有 <strong>article后代的所有p元素</strong> 才会应用此样式</p><p>又如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">h1</span> <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>:green; &#125;</span><br></pre></td></tr></table></figure><p>表示选中的p必须有一个祖先是h1，h1还要有个祖先是article</p><hr><p><br></p><h3 id="1-2、特殊的上下文选择器"><a href="#1-2、特殊的上下文选择器" class="headerlink" title="1.2、特殊的上下文选择器"></a><strong>1.2、特殊的上下文选择器</strong></h3><p>所用示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>An H2 Heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2 has <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>a link<span class="tag">&lt;/<span class="name">a</span>&gt;</span> in it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码的显示效果如下：</p><p><img src="/2018/09/02/CSS选择器(一)/1.png" alt="Alt text"><br><br></p><h4 id="子选择符-gt"><a href="#子选择符-gt" class="headerlink" title="子选择符 &gt;"></a><strong>子选择符 &gt;</strong></h4><p>用法：<strong>标签1 &gt; 标签2 { 声明 }</strong></p><p>下面我们给示例代码用子选择符添加样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &gt; <span class="selector-tag">h2</span> &#123; <span class="attribute">font-style</span>:italic; &#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/09/02/CSS选择器(一)/2.png" alt="示例1"></p><p>标签2必须是标签1的子元素，与常规的上下文选择符不同，这个选择符中的标签1不能是标签2的父元素之外的其他祖先元素。<br><br></p><h4 id="紧邻同胞选择符"><a href="#紧邻同胞选择符" class="headerlink" title="紧邻同胞选择符  +"></a><strong>紧邻同胞选择符  +</strong></h4><p>用法：<strong>标签1 + 标签2 { 声明 }</strong><br>例如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> + <span class="selector-tag">p</span> &#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/02/CSS选择器(一)/3.png" alt="Alt text"><br>标签2必须紧邻标签1，否则不会被选择到，比如，如果将p元素换成a元素，由于a元素没有紧邻p元素，所以a元素不会被选择到。<br><br></p><h4 id="一般同胞选择符"><a href="#一般同胞选择符" class="headerlink" title="一般同胞选择符 ~"></a><strong>一般同胞选择符 ~</strong></h4><p>用法：<strong>标签1 ~ 标签2 { 声明 }</strong> </p><p>例如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> ~ <span class="selector-tag">a</span> &#123;<span class="attribute">font-weight</span>:italic;&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/02/CSS选择器(一)/4.png" alt="Alt text"></p><p>可以看到h2的同胞元素a被选中，而p元素中的a元素却没有被选择到，也就是说一般同胞选择符只能选择到同胞元素，<strong>并且是在标签1之后的元素</strong>，两个元素之间不一定要紧邻，这也是和紧邻同胞选择符的一个区别之一<br><br></p><h4 id="通用选择符"><a href="#通用选择符" class="headerlink" title="通用选择符 *"></a><strong>通用选择符 *</strong></h4><p>用法：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123;<span class="attribute">color</span>:green&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这样会导致所有元素的文字和边框颜色变成绿色，一般在使用时都会同时使用另一个选择符</p></blockquote><p>比如:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> * &#123;<span class="attribute">color</span>:green&#125;</span><br></pre></td></tr></table></figure></p><p><strong>这样就会把p包含的所有元素的文本(不包括p本身的文本！)成绿色。</strong><br>还可以用它来构成非子选择符<br>例如:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> * <span class="selector-tag">a</span> &#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/02/CSS选择器(一)/5.png" alt="Alt text"></p><p>可以看到并没有选中section的子元素a，而是选中了section的孙子元素a。也就是说，任何section的孙子元素，而非子元素a都会被选中，与a的父元素没有关系。</p><hr><p><br></p><h3 id="2-1、类选择器"><a href="#2-1、类选择器" class="headerlink" title="2.1、类选择器"></a><strong>2.1、类选择器</strong></h3><p>所用示例代码：可以看到已经为h1和p标签添加了specialtext类</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"specialtext"</span>&gt;</span>This is a heading with the <span class="tag">&lt;<span class="name">span</span>&gt;</span>same class<span class="tag">&lt;/<span class="name">span</span>&gt;</span>as the second paragraph.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This tag has no class.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"specialtext"</span>&gt;</span> When a tag has a class attribute, you can target it <span class="tag">&lt;<span class="name">span</span>&gt;</span>regardless<span class="tag">&lt;/<span class="name">span</span>&gt;</span> of its position in the hierarchy.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="/images/placeholder.png" alt="Alt text" data-src="6.png" class="lazyload"><br><br></p><h3 id="2-2、类选择符"><a href="#2-2、类选择符" class="headerlink" title="2.2、类选择符"></a><strong>2.2、类选择符</strong></h3><p>用法：<strong>.类名 {声明}</strong></p><p>例如:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.specialtext</span> &#123; <span class="attribute">font-style</span>:italic; &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/placeholder.png" alt="Alt text" data-src="7.png" class="lazyload"></p><p>可以看到包含有specialtext类的标签全部被选中，<strong>且span元素由于我们没有为其添加样式，所以就继承了父元素的样式</strong><br><br></p><h3 id="2-3、标签带类选择符"><a href="#2-3、标签带类选择符" class="headerlink" title="2.3、标签带类选择符"></a><strong>2.3、标签带类选择符</strong></h3><p>假如只想让带有specialtext的p元素被选中，可以使用p.specialtext<br>例如:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.sepcialtext</span> &#123; <span class="attribute">font-style</span>:italic; &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/placeholder.png" alt="Alt text" data-src="8.png" class="lazyload"><br>可以看到带有specialtext的p标签被选中</p><h3 id="2-4、多类选择符"><a href="#2-4、多类选择符" class="headerlink" title="2.4、多类选择符"></a><strong>2.4、多类选择符</strong></h3><ul><li>可以给一个元素添加多个类，比如</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"specialtext featured"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>要选择同时存在这两个类名的元素，可以这样写</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.specialtext</span><span class="selector-class">.featured</span> &#123;<span class="attribute">font-size</span>:<span class="number">120%</span>;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>两个类名之间是没有空格的，若加了空格则变成了“祖先 后代”的上下文选择符</p><hr><p><br></p><h3 id="3-1、ID选择器"><a href="#3-1、ID选择器" class="headerlink" title="3.1、ID选择器"></a><strong>3.1、ID选择器</strong></h3><p>如果有一个段落像下面这样设定了 ID属性 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"specialtext"</span>&gt;</span>This is the special text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 那么，相应的 ID选择符就是这样的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#specialtext &#123;CSS 样式声明&#125;</span><br></pre></td></tr></table></figure></p><p> 或者这样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p#specialtext &#123;CSS 样式声明&#125;</span><br></pre></td></tr></table></figure><p>除此之外，ID与类的用法都一样，而且我们前面的关于类选择符的（几乎）一切，都适应于 ID选择符。</p><p><br></p><h3 id="3-2、类选择器与ID选择器的区别"><a href="#3-2、类选择器与ID选择器的区别" class="headerlink" title="3.2、类选择器与ID选择器的区别"></a>3.2、类选择器与ID选择器的区别</h3><ul><li><strong>ID选择器可用于页面导航</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#bio"</span>&gt;</span>Biography<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">"bio"</span>&gt;</span>Biography<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单击链接时，页面会向下滚动到 id 值为 bio 的 h3 元素的位置，如果链接的 href 属性里只有一个#，那么点击该链接会返回页面顶部。<br>若暂时不知道 href 应该放什么 URL，可以用 # 作为占位符，但不能留空。因为 href 属性值为空的链接的行为跟正常链接不一样。这样团队中的其他人将来可 以用中间层（比如 PHP）变量替换 # ，以便动态接收来自数据库的 URL 。</p></blockquote><ul><li><strong>什么时候用ID？</strong> </li></ul><blockquote><p>ID 是唯一的，同一个页面中每个 ID 只能用一次。<br>一般给页面中的每个顶级区域都添加一个 ID，这样就能得到非常明确的上下文。</p></blockquote><ul><li><strong>什么时候用类？</strong> </li></ul><blockquote><p>类的目的是为了标识一组具有相同特征的元素。</p></blockquote><p>在下面这个孩子名字的列表中，我想把男孩的名字变成蓝色，把女孩的名字变成粉 红色。首先，我用类在标记中标识出了性别</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"boy"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Alan<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"boy"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Andrew<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"girl"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Angela<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"boy"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Angus<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"girl"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Anne<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"girl"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Annette<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，再用 CSS为链接应用颜色： </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.boy</span> <span class="selector-tag">a</span> &#123;<span class="attribute">color</span>:<span class="number">#6CF</span>;&#125;<span class="comment">/*蓝色*/</span> </span><br><span class="line"><span class="selector-class">.girl</span> <span class="selector-tag">a</span> &#123;<span class="attribute">color</span>:<span class="number">#F9C</span>;&#125;<span class="comment">/*粉红色*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>不要乱用类</strong></li></ul><blockquote><p>不要像使用 ID 一样，每个类都指定一个不同的类名，然后再为每个类编写规则，这样你可能会给每个标签都重复写同样的样式。实际上，继承和上下文选择符能让不同的标签共享样式，从而降低你需要编写和维护的 CSS 量。</p></blockquote><hr>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/26/hello-world/"/>
      <content type="html"><![CDATA[<p><img src="/2018/08/26/hello-world/banner.jpg" alt="banner"></p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br></pre></td></tr></table></figure><blockquote><p><strong>some test</strong><br><strong>中文测试</strong></p></blockquote><p><strong>some test</strong></p><h1 id="中文测试"><a href="#中文测试" class="headerlink" title="中文测试"></a><strong>中文测试</strong></h1>]]></content>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
