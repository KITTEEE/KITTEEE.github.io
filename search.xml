<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>《三体》中的思想实验(四)：死神永生(上)</title>
      <link href="/2018/10/25/%E4%B8%89%E4%BD%93%E4%B8%AD%E7%9A%84%E6%80%9D%E6%83%B3%E5%AE%9E%E9%AA%8C%E5%9B%9B/"/>
      <content type="html"><![CDATA[<p>上一篇文章说道，一位叫罗辑的人，成功利用宇宙的黑暗森林法则，在太阳系建立了一套可以随时暴露三体人恒星坐标的装置。人类就凭借着这个威慑，成功把三体人拉到了谈判桌前，让两个文明进入了一个彼此对峙的平衡状态。<br><a id="more"></a></p><h3 id="实验十"><a href="#实验十" class="headerlink" title="实验十"></a>实验十</h3><p>如果两个敌对势力处于不稳定的平衡状态，那“强势”的一方应该注意些什么？</p><p>什么叫“不稳定”的平衡状态呢？就是在处于平衡状态下的其中一方，是很不情愿的，是很想改变现状的，只不过是暂时找不到办法，而三体人就是特别想打破这种状态的强势的一方。那么三体人是怎么做的呢？</p><p>总结一下，其实是两点：</p><blockquote><p>让对方感到，你在真诚地满足他。<br>寻找打破稳定的可能。</p></blockquote><p>第一点，真诚地满足对方。三体人这方面的事做的是真好，成功的让人们感到三体人的真诚。自从罗辑建立了黑暗森林威慑之后，人类上来就提出一个要求，就是：罗辑建立的这个靠核弹暴露位置信息的威慑手段太不靠谱了，万一核弹飘走了呢？所以我要你三体人帮我建立一个引力波的发射装置，为了我可以更好地威慑你。而且我要一次性建 4 个，3 个固定的，1 个移动的。可以吗？三体人一点也没犹豫，马上说可以。我帮你建三个，亚洲一个，美洲一个，欧洲一个，而且建造一个移动的。万一地球上的三个引力波装置被你们同时毁掉了，我们在宇宙移动的引力波装置也可以对你们造成威慑。于是，三体人在一艘叫“万有引力”的飞船上，建造了一个引力波发射器。</p><p>这里说一下，为什么是引力波，因为引力波很可能是宇宙最通用的通讯手段，它不受物质的阻挡，甚至可能穿越空间维度传播。它可能是宇宙里最靠谱的传递信息的手段。</p><p>接下来，地球人说，我要科技，给我科技。三体人马上说可以，给。然后就扔过来一堆科技，全是人类被憋了200多年的基础科学，物理学、数学、天文学，真的是应有尽有。人类科学家一看，都是好东西，而且很硬，都有点消化不了，三体人还嫌人类慢，说你们学完没呢？我这还有呢，快点学。人类这次，又感到了三体人的真诚。好，这是第一点。</p><p>第二点，听上去就让人感到三体人的可怕了。就是，三体人无时不刻地，在寻找打破这种平衡的可能。首先，三体人在自己的行星上，拼命研究最新的科技，他们知道自己之前吃亏就吃在飞船飞得太慢上了，如果不是要飞400年的话，也不会惹出这么多事来，必须提高飞船的航速。</p><p>很快三体人就取得了突破，他们掌握了光速飞行的技术。对人类绝对保密。还有，他们每时每刻都在监视着地球上的动静，一直在找人类黑暗森林威慑的一切可能的漏洞。同时，三体人在地球和太阳之间的一块太空垃圾里，藏了 6 个水滴，可以说是杀气腾腾的 6 个水滴，一旦有机会就能冲出来。但是这个机会实在是不好找，三体人和人类的这种你好我好的日子，一共过了 60 年，三体人也忍辱负重了 60 年。不过最后，三体人终于找到这个机会了，而且一次性把人类拿下了。</p><p>回到思想实验，我们的收获是什么呢？是教我们先忍辱负重地憋着忍着，然后找到机会一次性翻脸吗？还真不是。因为这里有一个最大的区别，就是在小说里，三体人和人类在本质上，不是同一个物种。但是我们平时生活里的那些情侣，合作伙伴，还有股东，毕竟不是三体人嘛，所以大家是没什么不能调和的本质矛盾的啊。</p><p>我们举个例子吧。比如说，你是个女生，你有一个很不靠谱的男朋友，但因为某个特殊的原因，你们俩暂时还真的分不开。那你的最差选项就是，一边抱怨一边试图改变他。而你的最优选项是，一边真诚地满足他，一边积极地让自己离得开他。这就是一种特别积极主动的人生。首先你长期对他好，有一定的概率，他自己会改变，或者会变得珍惜你，刚才说了，他毕竟不是三体人。如果他真是一点变化也没有，那对不起，我将来找到了更好的人，于情于理，我心里也不会有太多的愧疚。</p><p>我们看，三体人的这点就做得很好，我既然想明白了，目标是要真诚满足人类，那就痛痛快快，大大方方地满足你们，不要捏着鼻子，忍着恶心做这些事。你要是这样，对方一定会觉得你不真诚。那如果对方就是一点变化也没有，怎么办呢？第二条就是给这种情况准备的，一定不要放弃打破这种平衡的机会。说大白话，就是积极找下家。而且，要确保这样的行动一次性成功。这两种做法，一定要同时使用，才是最高效的。这样无论于情于理，你都没有亏欠对方。</p><p>这是我们的第一个段落。刚才我们是用三体人的视角来看这个问题，下面把视角切换到人类这边。</p><p><br></p><h3 id="实验十一"><a href="#实验十一" class="headerlink" title="实验十一"></a>实验十一</h3><p>一个合格的执剑人，应该具备什么性格？</p><p>所谓“执剑人”，就是人类掌握黑暗打击按钮的那个人。这个角色其实跟美苏冷战时候，总统手里的那个核按钮很像。小说里，执剑人的手里，也拿着一个像权杖一样的东西，上面是发射引力波的按钮，要做的工作也很简单，就是一旦发现三体人违约，就按下按钮，与三体人同归于尽。</p><p>刚才我们已经说过了，在人类的要求下，三体人建造了 4 个引力波发射器，确保在硬件上，威慑是可靠的，这是一个非常正确的决定。那接下来，就是要确保执剑人在性格上，要适合当执剑人。罗辑是第一代执剑人。在他的任期里，一切平稳。但罗辑已经 100 多岁了，人类社会认为，有必要更换一位执剑人。</p><p>在所有候选人里面，有两个候选人脱颖而出，一个叫程心，一个叫维德。程心是一个大美女，也是《三体3》的女主角，她是一个圣母一样的人，她参加执剑人竞选的口号就是，爱是解决一切的手段，就算是和三体人的星际矛盾，也可以用爱来解决。民众就觉得，我们现在跟三体人关系这么好，而且打了这么多年仗，我们也确实烦了。所以程心的呼声很高。</p><p>另外一个人叫维德，他这人是一个不达目的绝不罢休的大叔，是一个绝对的狠人。其实三体人特别害怕维德当上执剑人。但是民众在这个二选一的过程里，就选错了。程心呼声特别高，眼看就要当选。这时候维德就铤而走险了，他派了一个杀手搞暗杀，结果程心只是被打伤了，维德一下被判了 30 年监禁。程心反而获得了民众的巨大同情，最后以绝对优势当选了执剑人。然后，罗辑就交出了黑暗森林威慑，把控制着威慑权的那个权杖，交到了程心手里。</p><p>结果，程心接过来的下一秒。事情突然就变了。这就是三体人等了 60 年的机会，藏在太空里的6个水滴，飞快地冲出来，直接朝地球上的三个引力波发射器撞过去。说白了，三体人也没用什么计谋，他们就是赌程心不敢按按钮。这时候，程心刚接过权杖，还没明白是咋回事呢，周围就突然警报大作，所有警报都是告诉她，6 个水滴正在全速冲过来，引力波发射器马上会要破坏了。程心就蒙了，她就问自己，这时候如果按下按钮，同时毁掉两个文明，又有什么意义呢？这和她爱的初衷是相违背的啊！最后，她干脆把权杖扔到地上去了。三体人完美地预测了程心的反应。</p><p>结果，地球上的 3 个引力波发射站同时被水滴撞毁了。同一刻，那艘装着引力波发射器的万有引力号战舰，也和地球失去联系了。说明三体人的袭击是同时发生的。就在短短的十几分钟之内，人类建立的 60 年的威慑全部消失了。</p><p>回到我们刚才提出的这个问题，一个执剑人应该具备什么性格。小说里其实给出了明确的答案，要是一个不讲情面、恪守信念的狠人。而不是一个老好人。那怎么界定狠人和老好人呢？我们给一个概念上的判断，狠人的定义，就是如果你伤害他，他一定会让你付出相应的代价，而且这代价是什么，是有清晰的规则的。但是老好人的定义，就是如果你伤害了他，他可能会因为宽容或者是软弱，不让你付出相应的代价的人。所以从这个定义来看，程心是最烂选项。</p><p>程心这样性格的人，做朋友还行，她就根本不适合做任何形式的领袖。而我们能从这个段落里得到的收获，也是关于怎么塑造领袖人格的。领袖的一个重要素质，就是坚决地执行规则，哪怕在执行规则的过程里，有再大的阵痛，都是优先执行规则。只有长期这么对待事情，才能形成别人对你的一个可以预期的判断，这样的人才适合做领袖。</p><p>这是我们第二个思想实验。</p><p>下面我们就不看思想实验了，先来看一段故事。人类建立的黑暗森林威慑消失了之后，三体人的脸变得那叫一个快，说，没有威慑了是吧，那就听我的吧。这个时候，来地球已经两百多年的智子，成为了三体人在地球上的发言人，智子使用了一个人形机器人的形象，是一个非常漂亮的年轻日本女性。她对人类发言的时候，就是在代表三体世界的。<br>智子说，好，三体人舰队已经调头回来了，而且我们还从三体行星派出了第二拨移民船队。地球我们要定了。现在，你们四十亿人类全部都给我移民到澳大利亚去。消息一公布，人类都不动，等于大家都在观望。三体人说怎么我说了不算吗？派6个水滴把几个地球城市撞成了一片废墟，一下死了几十万人。这下人类害怕了。这个时候智子说，三体人现在公开招募500万地球治安军，说白了就是人类的伪军。结果人类很没出息，几亿人报名。地球治安军就拿着人类的武器，指挥着人类，用了半年时间，剩下的人类全都乖乖转移到澳大利亚去了。</p><p>但人类也有人坚决不服从，这些人就是地球反抗军。这些人在废墟里，在下水道里坚持战斗，但很可惜，他们只能和人类伪军作战，一个三体人也打不着。但他们的存在，维持了人类的尊严。罗辑老人也加入了反抗军，成为了反抗军的精神领袖。而人类的圣母程心，跟着人群到了澳大利亚。在澳大利亚，智子公开发表了一个讲话，人类才知道，澳大利亚的电源将被全部切断，不给粮食和任何补给，从现在开始，人类就人吃人吧。什么时候 40亿 人吃到只剩 5000万 人，我们再发粮食。在未来的计划里，我们只打算养 5000万 个人类。人类完全傻了，但是一点办法也没有。这个时候人类也终于明白过来，什么所谓的爱啊，那可能是我们需要的目的，但根本不是达成的手段。</p><p>但是，故事讲到这里，转折点马上就要出现了，因为要灭亡的不是人类，而是三体人。到底怎么回事？我们要把视角切换到宇宙里。拯救整个人类的，就是那艘带着引力波发射器的星际战舰——万有引力号。在水滴撞坏地球上的 3 个引力波发射器的时候，万有引力号正在外太空执行任务呢。三体人早派出了两个水滴，去监视万有引力号。就在地球这边三体人和人类翻脸的时候，外太空的这两个水滴也同时接到了指令，把万有引力号同时干掉。但就在这个时候，人类人品大爆发，同时遇到了两个黑天鹅事件，就是这两个小概率事件让万有引力号活下来了。</p><p>第一个黑天鹅事件，是万有引力号和两艘水滴，一起进入了宇宙里的一片通讯盲区，就像一个没有手机信号的区域。所以，在这个盲区里发生的所有事情，外面的三体人是不知道的。第二个事件，是人类突然进入了一块四维空间的碎片。这个碎片就是随机地分布在宇宙里，万有引力号就是这么好运，被它碰上了。进入四维空间之后，人类就获得了一些很神奇的能力。</p><p>四维空间里的人，是可以对三维世界里的东西进行高维俯视的，比如你在四维空间里，看一个三维世界里的人，是能同时看见他的内脏、肌肉、血液的。同时，四维空间里的人，还可以对这些三维世界的人进行高维触摸。比如一伸手，可以直接摸到对方的心脏上，这个过程不会破坏他的胸腔，因为你是从高维空间直接进入到低维空间的。也就是这么巧，就在这个时候，水滴接到命令，正要攻击万有引力号。人类对水滴发起了高维攻击。也就是在四维空间里，直接进到水滴的肚子里，从里边把水滴给毁了。水滴的外壳很坚硬，但是肚子里很脆弱。人类灭掉水滴，就是一个典型的所谓“高维打低维”的例子。</p><p>然后，万有引力号上的舰员开会一商量，一致认为，三体人和人类在地球上是扯破脸了。那万有引力号的职责，就是在这个时候实施黑暗森林报复。事关重大，战舰上的军人就进行了一个表决，他们可不像程心那么脆弱，表决的结果是，开启引力波发射器。也就是这个行为，把地球给救了。所以，万有引力号，向整个宇宙，公布了三体恒星的位置信息，三体人的恒星系马上变成了所有猎人瞄准的死亡之地。</p><p>宇宙里的事先说到这。我们把叙事的视角切换回地球。全体人类在澳大利亚突然得到一个消息，说是三体人撤了，地球治安军也解散了，所有人从哪来就回哪去。后来，大家才知道，这是因为万有引力号公布了三体恒星系的坐标，三体恒星系和太阳系这俩地方已经不能呆人了。三体人直接选择跑路了。</p><p>三年之后，黑暗打击如约而至，漆黑的宇宙里，突然出现了一颗明亮的小光点，直接击中了三体恒星，造成了恒星一系列大爆炸，三体行星被恒星吞没了。大概只有不到千分之一的三体人逃出来了，剩下的全部葬身火海。打击肯定是从一艘宇宙飞船上发出来的，因为开枪的那个位置没有任何天体的。飞船几乎是收到信号后马上开枪，一点时间也没耽误。就在三体人决定侵略地球的 300 年后，三体行星，被这个他看不上的人类，利用黑暗森林打击灭掉了。但是，三体文明，并没有灭绝。接下来我们来看最后一个思想实验。</p><p><br></p><h3 id="实验十二"><a href="#实验十二" class="headerlink" title="实验十二"></a>实验十二</h3><p>一个成熟的文明，应该怎样面对已经没有威胁的敌人？</p><p>就在三体行星被毁的第三天，智子，也就是那个美丽的日本机器人。突然把程心和罗辑约到家里了。说是一起喝喝茶，叙叙旧。智子泡了三杯茶，用非常平静的语气，对罗辑和程心说了下面4层意思。算是她代表三体文明对人类最后想说的话。</p><p>第一层意思，向你们通报一下我们的情况。我们的行星被毁了。以后，我们就是宇宙里的一个流浪文明了。200 年前出发的第一拨舰队和第二拨舰队，现在是唯一的三体人火种了。第二层意思，我们的智子也会从地球上撤离了。以后，三体人就再也不祸害你们地球人了，没有人监视你们了，你们的理论物理也没有天花板了。你们自己加油。第三层意思，不要以为你很安全，公布了我们的坐标之后，我们两个文明之间的通讯记录很快就被高等文明发现，黑暗打击很快会降临在你们头上，人类，请快跑。第四层意思，宇宙很大，彼此珍重，如果有缘的话，我们再见。</p><p>说完，智子微笑着，给程心和罗辑递上一杯茶。一杯淡茶，算是对这场星际战争的一个总结吧。说实话，罗辑和程心也没想到三体人最后说出这么一番话来。听完之后，突然对这个敌人，产生了一种复杂的情感。人类和三体人的关系，可以叫已经没有威胁的一双敌人。三体人在临走之前，还来了一个挺有水平的告别。我们基本可以用三个原则总结三体人对一个没有威胁的敌人的态度。</p><p>第一原则，无对无错。在最后的陈词里，三体人只说事实，没有任何一句是非判断。第二原则，无怨无恨。三体人完全没有提谁的损失大，谁的过失多，或者谁的未来更渺茫这些东西。而且三体人也没有报复和诅咒的行动，就是这么沉默地走了。任何坑你的事情，三体人都没做。第三原则，有礼有节。三体人走的时候，算是有一个正式的告别的。做事有头有尾，而且作为礼貌性的告别</p><p>所以三体人走的时候，留给人类的，是一个性格非常稳重，情绪非常平和的形象。而且留的都是活话，万一日后再见了，起码是好再打招呼的。你看，这种面对旧敌人的态度，和我们熟悉的方式完全不一样。用我们比较熟悉的观点来说这场战争，肯定是这种调调的，这就是三体侵略者搬起石头砸了自己的脚，最后得到这么一个下场，罪有应得！而且，是三体人你们先打我们的，你们这是一场不义的战争，而且，以后你就得永远低头认错，以后无论啥时候见面了，你就给我道歉。而且，只要我将来有机会，我一定要把你今天对我做的十倍地还给你，你等着，以后我们无论什么时候看见对方，我们都是仇人。</p><p>你看，刚才这种论断，就全是是非对错，全是怨恨，全是过去，没有一点未来。在宇宙生存面前，这些是非曲直，是最苍白的东西。如果一个文明老是揪住这些东西不放，那它就不是一个成熟的文明。这些或许就是三体这个文明在离我们而去的时候，给我们的最后的一些收获。</p><p>就在智子马上要告别之前，罗辑突然开口了，他说，我能问一个问题吗？智子想了一会，点了点头。说，我回答你，完全是出于对您罗辑的敬重，但我只能回答，是、否，或者不知道。我的回答肯定是真实的。罗辑一字一句地问道：在宇宙里，有没有一种通用的安全声明，进而能避免黑暗森林打击呢？智子听了之后，明确点点头，说：有。</p><p>说到这，《三体3》上半部分的情节就结束了。那究竟这个神秘的安全声明是什么呢？人类又能不能躲开这次黑暗森林打击呢？《三体3·死神永生》的下半部分，也是三体三部曲的大结局。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>JS实现数据结构与算法：数组</title>
      <link href="/2018/10/20/JS%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-%E6%95%B0%E7%BB%84/"/>
      <content type="html"><![CDATA[<p><img src="/2018/10/20/JS算法实现-数组/banner.jpg" alt="banner"></p><a id="more"></a>]]></content>
      
      
        <tags>
            
            <tag> 数据结构与算法之美 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构与算法：数组</title>
      <link href="/2018/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/"/>
      <content type="html"><![CDATA[<p><img src="/2018/10/16/数据结构与算法-数组/banner.jpg" alt="Alt text"><br>为什么数组要从 0 开始编号，而不是从 1 开始？<br><a id="more"></a><br><br></p><h3 id="一、什么是数组"><a href="#一、什么是数组" class="headerlink" title="一、什么是数组"></a>一、什么是数组</h3><blockquote><p>数组 (Array) 是一种线性表数据结构，它用一组连续的内存空间，来存储一组相同类型的数据</p></blockquote><p>上面这句话中说到了数组的两个特性，第一个是 <strong>「线性表」</strong>，第二个是 <strong>「连续的内存空间」</strong>。</p><p>「线性表」指的是数据排成一条线一样的数据结构，且上面的数据最多只有前和后两个方向，除了数组，链表、队列、栈 等都是线性表结构。<br><img src="/2018/10/16/数据结构与算法-数组/1.jpg" alt="Alt text"><br>与线性表相对应的是非线性表结构，也就是结构里的数据之间不只有简单的前后关系，如图、二叉树、堆等。<br><img src="/2018/10/16/数据结构与算法-数组/2.jpg" alt="Alt text"></p><p>「连续的内存空间和相同类型的数据」指的是数组中的数据在内存中的存储是连续的，因为这个特性所以数组能够实现「随机访问」，但也因此数组的插入删除等操作变得低效。</p><p><br></p><h3 id="二、数组是如何实现随机访问的"><a href="#二、数组是如何实现随机访问的" class="headerlink" title="二、数组是如何实现随机访问的"></a>二、数组是如何实现随机访问的</h3><p>拿一个长度为 10 的 int 类型数组 int a[] 举例，在计算机中，计算机会给 a 数组 分配一块连续的内存空间 (如下图)，其中，计算机会给每个内存单元分配一个地址，需要访问到数组中的元素的时候，计算机会通过「寻址公式」来计算出数据存储的内存地址，再通过地址来访问内存中的数据。</p><p>寻址公式：<code>a[i]_address = base_address + i * data_type_size</code></p><p>其中，base_address 为数组内存块的首地址，data_type_size 为数组的数据类型长度，如 int 的数据类型长度为 4 。 </p><p><img src="/2018/10/16/数据结构与算法-数组/3.jpg" alt="Alt text"></p><p><br></p><h3 id="三、低效的插入和删除操作"><a href="#三、低效的插入和删除操作" class="headerlink" title="三、低效的插入和删除操作"></a>三、低效的插入和删除操作</h3><p>数组为了保持内存的连续性，因此它的插入和删除操作变得十分低效。</p><p>假设有一个长度为 n 的数组，我们要在第 k 位中插入一个数据，为了保持内存的连续性，就必须将第 k 为后的 k-n 个数据往后移动一位。</p><p>如果在数组的末尾插入元素，数据无需移动，最好情况时间复杂度为 O(1)，若在数组首位插入元素，则所有元素都必须往后移动一位，最坏情况时间复杂度为 O(n)，由于每个位置插入元素的概率是一样的，因此平均时间时间复杂度为 (1+2+…+n)/n = O(n) 。</p><p>而数组的删除操作与插入操作类似，删除数组末尾元素最好时间复杂度为 O(1)，删除数组的首元素最坏时间复杂度为 O(n)，平均时间复杂度也为 O(n)。</p><p><strong>实际上，在某些场景中，我们并不需要一定追求数据的连续性。</strong></p><p>例如删除操作，假如数组 a[10] 中存储了 a~h 一共 8 个元素，我们要依次删除 a、b、c 三个元素，为了避免 d~h 这几个数据被搬运三次，我们可以先记录下已经删除的数据，每次删除数据并不是真正地搬移数据，只是记录数据已经被删除，当数组中没有更多空间存储数据时，如果我们将这三次删除操作集中在一起执行，触发一次真正的删除操作，这样删除的效率就会高效很多。这也是 JVM 中的 <strong>标记清除垃圾回收算法</strong> 的核心思想。</p><p><br></p><h3 id="四、警惕数组越界"><a href="#四、警惕数组越界" class="headerlink" title="四、警惕数组越界"></a>四、警惕数组越界</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的运行结果不是打印三次 hello world ，而是打印无限次 hello world。因为数组大小为 3 ，而由于 for 循环中的条件为 i &lt;= 3 ，当 i = 3 时，数组 a[3] 访问越界。</p><p>在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以访问的，根据前面的寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址刚好是存储变量 i 的内存地址，因此 a[3]=0 就相当于 i = 0，计算机访问到了数组首元素的地址，导致了代码的无限循环。</p><p>因为访问数组本身就是在访问一段连续的内存，只要通过寻址公式的得到的内存地址是可用的，程序就不会报错误，所以经常会出现一些奇怪的逻辑错误问题。数组越界在 C 语言中是一种未决行为，编译器也没有规定在数组越界时该如何处理。但也并非所有语言都会把数组越界检查交给程序员来做，像 java 就会做越界检查并抛出错误。</p><p><br></p><h3 id="五、容器能否完全替代数组？"><a href="#五、容器能否完全替代数组？" class="headerlink" title="五、容器能否完全替代数组？"></a>五、容器能否完全替代数组？</h3><p>很多语言为数组类型提供了容器，用 java 的 ArrayList 举例，它封装了很多数组的操作细节，如插入删除及搬运数据等；还有就是支持动态扩容，每当存储空间不够的时候，都会自动将空间扩容到 1.5 倍大小。而数组在定义前就要先指定好大小，为它分配一段连续的内存空间，而当数组的内存空间不够时，就需要申请一块更大的内存空间，再将原来的数据复制过去。这样比较起来，使用容器效率比用数组要高得多。</p><p>数组比较适用的场景：</p><ul><li>若数据大小已知，且涉及的数据操作比较简单，可以用数组。</li><li>对于平常的业务开发，使用容器便足够，虽然只损耗一点点性能。对于非常底层的开发，性能的优化需要做到极致，这时数组会优于容器。</li><li>表示多维数组时，数组往往比容器更加客观。</li><li>若特别关注性能，可以选用数组</li></ul><p><br></p><h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><p><strong>为什么数组从 0 开始编号？</strong></p><p>解答：</p><p>如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，a[k]表示偏移 k 个 data_type_size 的位置，a[k]的地址计算就是这样的</p><blockquote><p>a[k]_address = base_address + k * data_type_size</p></blockquote><p>而如果从 1 开始计数，则为：</p><blockquote><p>a[k]_address = base_address + (k-1) * data_type_size</p></blockquote><p>从 1 开始计数多了一次减法操作，对 CPU 来说就多了一次减法指令，数组作为最基础的数据结构，为了使效率优化达到极致，所以选择从 0 开始编号 (也有一定的历史因素)<br><br><br><strong>二维数组的寻址公式是怎么样的？</strong></p><p>解答：</p><p>对于一个 m*n 的二维数组，a[i][j]的寻址公式为：<br>address = base_address + ( i*n + j ) * data_type_size</p>]]></content>
      
      
        <tags>
            
            <tag> 数据结构与算法之美 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《三体》中的思想实验(二)：黑暗森林(下)</title>
      <link href="/2018/10/09/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E4%B8%AD%E7%9A%84%E6%80%9D%E6%83%B3%E5%AE%9E%E9%AA%8C(%E4%BA%8C)%EF%BC%9A%E9%BB%91%E6%9A%97%E6%A3%AE%E6%9E%97(%E4%B8%8B)/"/>
      <content type="html"><![CDATA[<p>前面我们知道，人类在大低谷之后爆发了起义，人类的科技水平又触底反弹了，创造出了实力超强的星际战舰，而三体舰队则在穿过一片小行星带后只剩下很少一部分舰队了，人类感觉这边战斗我们赢定了。接下来，我们还是分三个思想实验来描述本文。</p><a id="more"></a><blockquote><p>原文作者：<a href="https://t.zsxq.com/62fIaU7" target="_blank" rel="noopener">Daotin</a></p></blockquote><p><img src="/2018/10/09/《三体》中的思想实验(二)：黑暗森林(下)/banner2.jpg" alt="Alt text"></p><p><br></p><h3 id="实验七"><a href="#实验七" class="headerlink" title="实验七"></a><strong>实验七</strong></h3><p><strong>如果两个理论物理水平有差距的文明作战，会出现什么样的情景呢？</strong></p><p>为什么会提出这个问题呢？人类这个时候由于造出了强大的星际战舰，就骄傲自大了起来。当时人们已经探测到三体人派出了一个接近光速的小飞船向地球靠近。一些人非得认为是三体人来向地球投降或者是向地球来谈判的的，甚至估计连台词都想好了，怎么招降三体人等等。于是人类可能是为了炫耀或者是为了振奋士气，就把所有 2015 艘星际战舰全部开往太阳系来截击这三体人的一艘小飞船。</p><p>或许被三体人压抑太久了，很多人情绪特别高涨，有的人甚至嚎啕大哭起来。然而，这支舰队却成了人类的绝唱，再也没有回来。</p><p>人类的庞大的舰队是在海王星的轨道第一次和三体人的小飞船相遇。这是人类第一次看到三体世界的物质。人类在看到三体人派来的小飞船的时候其实有点惊讶，因为老实说这个三体派来的小飞船太小了，大小也就像个小卡车一样大小。形状就像一个水滴，头是圆圆的，尾巴很尖的那种。全身都非常的光滑，像一面镜子一样，还蛮好看的。</p><p>当水滴看见人类的战舰之后就停了下来，一动不动的悬浮在空中，也不发出任何声音，就像静止了一样。这时候人类也派出了一艘小飞船去接近这个水滴，这个时候水滴还是一动不动的，人类心想，那好吧我先给你做个体检吧。就量了一下这个水滴的宽高啊等等，接着分析水滴表面的材料，人类把水滴表面的物质在显微镜下放大 1000 万倍进行观察，这一观察就把人类看呆了。因为在显微镜下，小飞船的表面还是像镜子一样光滑，没有丝毫的缝隙。而这在人类世界里的物质是完全不可能存在的。在人类的世界里，任何物质放大到这么多的倍数都会显得很杂乱，那么可想而知这个水滴的表面硬度是有多大。</p><p>当人们正在感叹的间隙，这个水滴突然开动起来，向人类的舰队冲了过来，速度非常快。而且人类的雷达是探测不到的水滴的。所以人们就是突然发现水滴消失不见了，然后有一艘战舰突然爆炸，一切都在一瞬间的功夫。水滴的攻击方式非常简单。就是拿脑袋去撞。而且它也不是随便撞的，它啥都懂。它是直接从战舰的中间燃料仓穿了过去的，没有丝毫的偏差，也没有丝毫的阻力，就像撞一块豆腐似的。</p><p>紧接着其他的战舰也开始陆续爆炸起来，这说明水滴开始穿其他的战舰了。由于人类的战舰排布非常整齐，水滴在穿的时候连弯儿都不需要拐，直接一秒一艘的穿。在 1 分 18 秒之后，人类舰队的第一排 100 艘战舰，全部爆炸，这个时候水滴已经绕到了第二排战舰的身后，准备穿第二排了。事后在看录像的时候，人们发现水滴从第一排到第二排的时候直接做了一个锐角转弯，而且做这个转弯的时候速度没有一丝减少，光是这一点，人们都傻眼了，因为这已经完全超出了人类物理学的理论范畴了。</p><p>就在水滴开始穿第四艘人类战舰的时候，终于有一艘战舰发现了水滴。于是就用伽马激光炮打中了水滴，然而水滴没有一点反应。还一个战舰也发现了水滴，向她水滴发射了一枚电磁轨道炮，就是一颗金属的炮弹打中了水滴。这时候水滴终于有了一丝反应，速度稍微降下了，而水滴也感觉到了有人在打他，就立马增加了推进，立刻就恢复到以前的速度。</p><p>打不过就跑啊，这个时候其他所有的战舰都开始四散逃走，而水滴就开始在空间中四处追杀人类的战舰，而且水滴追杀人类的战舰的路径是最短的，没有走一点冤枉路。50 分钟后人类只有七艘战舰逃了出来，其他的战舰全都一个接一个的爆炸，没有一丝声响，寂静的死亡。而人类最后的战果也只是稍微在几秒内减慢了水滴的移动速度而已。人类和三体的战损比为是 2009 : 0，这场战役后来被人类称为末日之战，人类之前所有的荣光都在这 50 分钟内消失殆尽。</p><p>回到思想实验，如果两个再理论物理水平有差异的两个文明，根本不可能打的有来有回。只能是一方。丝毫还不上手。人们终于明白了理论物理的重要性。三体人用智子来封锁人类的理论物理真的是四两拨千斤呀。人家根本就不在乎你们星际战舰的航速有多快，技术有多先进。人家水滴的速度也不快啊，而且攻击的方式就是你们人类最原始的冷兵器呀，就是拿脑袋去撞。不过人家拿的是放大 1000 万倍之后人员仍然光滑如镜面的脑袋去撞。所以对物质本质的理解才是最根本的问题。</p><p>如果上面是人类的末日之战，那么向下个思想实验，就是把人类最黑暗的一面暴露出来。<br><br></p><h3 id="实验八"><a href="#实验八" class="headerlink" title="实验八"></a><strong>实验八</strong></h3><p><strong>什么是猜疑链？</strong></p><p>前面我们说到人类有七艘战舰逃了出来。其中的五艘在一起飞向太阳系的一面，另外 两艘在一起飞向太阳系的另一面。这个时候，七艘战舰的舰长就会想，这个时候回太阳系肯定是不行的，水滴还在那里呢。回地球也是不行的，地球可能早晚被三体人占领，唯一的办法就是在宇宙中找其他的行星，先暂时站稳脚跟。</p><p>这个方向一旦确定，首先面临的一个问题就是燃料不够。这个时候人类最先产生了一个邪恶的想法就是我能不能从其他的战舰上偷过来。这个想法一旦出来，立马就会被人类的良知按下去。但是不一会人类的另一个想法又开始冒出来：我可以保证我不偷别人的，但是我怎么能保证其他人也不会偷我的你？所以我应该我是不是应该做点儿什么来在防卫呢？你看这个邪恶的想法立刻就变成了主动防御的意识。而且这还不够，因为我能想到其他人也可以想到。所以不仅需要主动防御，而且慢一点儿都不行。最后的结果就是五艘战舰的只剩下一艘。两艘战舰的也只剩下一艘。这场战役就被称为人类的黑暗之战！</p><p>那么这个思想实验想要告诉我们什么呢？是告诉我们下手要快吗，哈哈肯定不是的，告诉我们的是建立一个有规则和执法者的世界是多么的重要。我们来看看其实在黑暗之战之前，每个舰长都算了一笔经济账的，只需要一颗炮弹，就可以保证自己的绝对安全。这是非常划算的为什么不做呢？而如果有一套规则来约束的话，那么代价就变成了一颗炮弹 + 可能接受到了惩罚。那么就可能在动手前先过一下脑子。所以这个思想实验也就是要告诉人类，不要进入无政府的状态。</p><p>既然人类的无政府状态会爆发黑暗之战，那么宇宙的无政府状态会爆发什么呢？这就是下一个思想实验，宇宙的黑暗森林法则。<br><br></p><h3 id="实验九"><a href="#实验九" class="headerlink" title="实验九"></a><strong>实验九</strong></h3><p><strong>一个无政府的宇宙会演化出什么样的宇宙社会学呢？</strong></p><p>经过末日之战之后，人类彻底失去了信心。人类的执法者找到了罗辑并恢复了他的面壁者身份。因为之前人类不是造成了星际战舰嘛，自信心爆棚，就把面壁者计划取消了，罗辑也被从休眠状态叫醒了，混在了人堆里。这个时候罗辑土人被恢复了面壁者身份，就很好奇，哎，你们怎么把我给想起来了呢？执法者就说，当时被您公布的那个恒星系被一种神秘的力量毁掉了。我们也不知道您是怎么做到的，也不需要向我们解释，反正现在我们人类都听您的了。罗辑听到这时眼前一亮，这说明自己的理论是正确的，那么地球还有挽救的机会。</p><p>这时候就引出了本书一个大埂，黑暗森林法则。这个法则是罗辑根据叶文杰的话推导出来的。前面说过，罗辑和叶文杰见过一次面，叶文杰给逻辑说了四句话，两个公理和两个概念。</p><p>公理一，生存是文明的第一需要；公理二，文明不断增长和扩张，但是宇宙中的物质总量保持不变；概念一是猜疑链；概念二是技术爆炸。</p><p>逻辑最开始的时候也没有明白这四句话是什么意思。后来自己琢磨了一下，发现这四句话可以合成一句话。</p><p>先看公理一，生存是文明的第一需要。这话没什么可说的，你连生存都没有了还谈什么文明。</p><p>公理二，文明不断增长和扩张，但是宇宙中的物质总量保持不变。这就相当于，整个宇宙中的文明是一个零和博弈。也就是说，一个文明获得的物质多一点，其他的文明获得了物质就少一点。所以各个文明为了生存下去就会互相厮杀。</p><p>猜疑链，我们刚才已经说过了。</p><p>那什么是技术爆炸呢？由于宇宙之间，各个文明的相距的特别远。可能在一个文明赶路的过程中，另一个文明的技术会爆炸性的发展。就比如人类吧，如果不是三体人用智子封住人类的理论物理的话，那么人类的技术基本上可以称得上爆炸式增长。</p><p>所以这两个公理和两个概念连成一句话就是：宇宙是一个零和博弈，每个文明都以生存为第一要务，这是一个冷酷的世界。即使一个文明再弱小，也有可能在一瞬间发生技术爆炸。而且由于猜疑链的存在，在宇宙中一旦有个文明被发现，第一反应就是把这个文明干掉再说。</p><p>整个宇宙就相当于一个黑暗森林，一个无政府的状态。每一个文明都像一个带枪的猎人，宇宙的森林虽然是寂静无声的，但是都知道里面藏着很多文明。一旦一个文明被发现，就像黑暗森林的一团火光，所有的文明都会将枪口对准这火光广，不管这个文明弱小也好，强大也罢，先打一枪再说，因为一颗子弹就可以换来自己文明的安全。而之前被罗辑公布了的那颗恒星系就是被这样打掉的。之后整个宇宙又恢复了死一般的寂静。</p><p>而这也是为什么三体人害怕罗辑的原因，一旦罗辑把太阳系和三体星系的坐标位置公布出去，三体人一点办法都没有。罗辑的想法就是，我打不过你，但是我可以找人把我们全灭掉。</p><p>具体是怎么实现的呢？罗辑在当上面壁者之后推出了一个「雪地计划」。雪地计划是这样的，就是在太阳系地外圈围上一圈核弹，然后再在核弹的外面放上一层物质，然后引爆核弹。核弹引爆之后就会把这些物质炸开形成一层油乎乎的薄膜一样的隔离层。当三体人进来的时候就会在隔离层上留下痕迹，就像在雪地上踩上脚印了一样，这就是雪地计划。这个雪地计划其实就像一个预警装置，就是告诉人们啊，我看见三级人进来了。那么你们可能会问这有什么用啊？我们又打不过。但是逻辑说，嗯，我不管，反正我觉得有用。然后人们觉得，反正你都是面壁者了，那就听你的吧。于是人们花了一年半的时间来帮罗辑实现这个雪地计划，而罗辑就在整天在办公室里面研究图纸，研究每一颗核弹应该放置的位置。</p><p>一年之后，这个雪地计划终于完成了，每颗核弹都放到了相应的位置，就差引爆了。这时候罗辑走出办公室，去了一片墓地，给自己挖了一个坑，躺了进去，手里拿着一把枪对准自己的脑袋。他知道智子一直在看着他呢，就说：三体世界，我要和你对话。我的手腕儿上现在有一个生命探测器，一旦我没有了生命特征，就会向宇宙发射一个信号引爆这些核弹。这些核弹一旦引爆，就会把那些油膜一样的物质炸开，每个油墨污渍都会在宇宙中都会对应一个点。一共有 3614 颗核弹对应着三体星系和周围几十个恒星系的坐标。一旦爆炸就相当于在宇宙中公布了三级星系和附近恒星的位置，而由于是从地球发射出去的信号，所以太阳系的位置也被公布了。所以这个雪地计划就相当于向宇宙中暴露了三体人和我们恒星的位置。我现在数 30 秒，如果你们不理我我就引爆核弹。</p><p>只过了十秒左右，在罗辑的面前就出现了三个小球，每个小球上面都写了两个字“住手”。罗辑看到后说，要住手也可以，但是你们要照我说的做。然后小球上面又出现两个字“请讲”。逻辑就说，你们三体舰队不能进入太阳系。小球这时显示说，飞船的速度太快，即使全力减速也会冲进太阳系。逻辑就说，那你们就就偏离太阳系。小球说如果偏离太阳系的话，我们就会冲入荒无人烟的太空中，这个需要向最高长官请示。罗辑就说那就去请示吧，又过了三分钟的沉默时间。小球说好的，听您的。罗辑这时把顶在脑袋上的枪拿开，长长地出了一口气。笼罩在人们头上的乌云终于暂时散开了。</p><p>凭借罗辑建立了黑暗森林威慑，人类和三级人终于达成了一个平衡。故事讲到这里本书也就基本完结了。但是请注意。罗辑建立的这个黑暗森林威慑，只是达到了一个暂时的平衡，它是不稳定的。就相当于一个弱者突然掏出了一颗手榴弹，吓得大家都不敢轻举妄动。但是这种不稳定的状态迟早有一天会被打破的。</p><p>在三体小说世界的最后一部里，这种平衡还会继续演变，到时候人类不仅和三级人会战斗，而且还将面临宇宙中更可怕的东西。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>《三体》中的思想实验(二)：黑暗森林(上)</title>
      <link href="/2018/10/08/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E4%B8%AD%E7%9A%84%E6%80%9D%E6%83%B3%E5%AE%9E%E9%AA%8C(%E4%BA%8C)%EF%BC%9A%E9%BB%91%E6%9A%97%E6%A3%AE%E6%9E%97(%E4%B8%8A)/"/>
      <content type="html"><![CDATA[<p>上一篇我们说道，三体人用智子锁住我们的基础科学，还偷听人类的语言，监视人类的行动，然后大概 400 年后就杀气腾腾的到达地球，第二部分我们分 6 个思想实验来概括本书，我们先说前三个思想实验。<br><a id="more"></a></p><blockquote><p>原文作者：<a href="https://t.zsxq.com/62fIaU7" target="_blank" rel="noopener">Daotin</a></p></blockquote><p><img src="/2018/10/08/《三体》中的思想实验(二)：黑暗森林(上)/banner2.jpg" alt="Alt text"></p><p><br></p><h3 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a><strong>实验四</strong></h3><p><strong>如果人类社会变成一个思维完全透明的世界，是好事吗？</strong></p><p>为什么会提出这个问题呢？因为人类在截获的叛军的三体人资料中发现，三体种族是个信息完全透明的社会，就是心里想什么就会用嘴表达出来，除了睡觉之外，就像一个永不停息的电台一样，不停的向外发射信号。没有欺骗，虚伪和谎言。</p><p>于是有的人提出，三体人的信息透明是更高等的文明架构，为什么人类中有这么多欺骗和谎言呢，就是因为信息不透明。人类现在「人心隔肚皮」沟通方式是低效的，不利于社会文明的发展的，不然有可能就不是三体人欺负我们，而是我们欺负三体人了。</p><p>那么，我们试着从科学和社会学的角度来推理，如果人类社会变成一个思维完全透明的世界会是什么样子的呢？</p><p>首先，从科学的角度来说，这种全天时的内心独白是非常耗能的，我们平时连续说上一两个小时的话都觉得耗费很大的精力，如果一种生物不间断的向外发送信息，<br>那得消耗多少粮食才能负担得起这种消耗，对于个体的生存是非常不利的。</p><p>从社会学的角度来说，这种信息透明对人类也不是什么好事。你想，如果思维提透明了，什么话都直说，很多的协作都不容易展开。举个栗子，就比如谈恋爱吧，爱情也是一种协作，在最开始的阶段，双方都各自不清楚的情况下，慢慢摸索、了解，走着走着就有感情了，如果一开始，女方说我就是图你的钱，男方说我就是对你有生理需求，那双方都没法接受，可能就没法相处下去了。</p><p>再比如想要建设一个伟大的国家，就需要把人聚集到一起，为了一个共同的目标努力奋斗。但是你能保证所有的人都这么想吗？可能有人这么想，也可能有的就只想挣点钱，但是不碍事，只要能让所有人往一个方向走，即使那个人都有自己的小想法，也是有利于目标的实现的。</p><p>所以，综上所述，信息全透明对人类社会是不利的，所以我们在生活和工作当中遇到一些虚伪，欺骗或者是套路的时候，观点不要那么单一，能够有一点宽容的心态来看待，这也是我们从这个思想实验所学到的东西。</p><p>我们接下来继续来看小说故事，下面的故事也引入一个思想实验。</p><p><br></p><h3 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a><strong>实验五</strong></h3><p><strong>如果真的有外星人入侵，我们应该把决断权交给谁？</strong></p><p>我们之前说了，三体人派了一个叫智子的机器人，任何时候都在监视人类，但是智子唯一不能监视的，就是人类的思维。所以，针对这个特点，人类制定了「面壁者」计划。</p><p>面壁者计划，说得简单点，就是打造人类有史以来最厉害的四个骗子。他们的目标就是骗过全人类和三体人。给这四个人最大的权力，你们说什么，人类就干什么。但是所有动作都是为了演戏，演给智子和三体人看的。到最后用一种所有人都想不到的方法把三体人打败。</p><p>四个面壁者很快选出来了，但是前三个都失败了，只有第四个成功了，而这第四个人就是所有三体人都害怕的罗辑。</p><p>我们看看前三个人的决策和都是怎么失败的？</p><p><strong>第一位面壁者，是美国前国防部部长。</strong>他给出的计划是，用量子幽灵部队，去和三体人战斗。解释一下量子幽灵部队，它是假想用一种叫「球形闪电」的武器，攻击人类自己的军队，那人类的军队有可能会被打成量子态。量子态就可以理解成，一个人既在这里，也在那里，既是死亡的，也是活着的，所以，一个量子态的军队，就有点像一支死不了的幽灵部队。那这就很无敌了，基本可以和三体人一战了。</p><p>很遗憾，这个计划被三体人识破了，三体人的应对办法非常简单，就是直接把这个计划给公布在互联网上了。公布之后，广大不明真相的吃瓜群众就马上都来围观，围观之后就是舆论哗然。反对的声音非常大，大家就说，你这是拿自己人当小白鼠做实验啊，万一没打成量子态，打死了怎么办？你这方法不靠谱啊！</p><p>最后在强大的民众舆论下，这个国防部长开枪自杀了，这第一个计划以失败告终。</p><p><strong>第二位面壁者是委内瑞拉总统。</strong>他的计划是在水星背对太阳的那一侧，放很多颗氢弹。如果要是引爆这些氢弹呢，就能把水星炸得脱离自己的轨道，最后掉到太阳里去。然后在太阳肚子里就会发生各种链式反应，最后的结果是，地球也会被卷进去。所以这个计划其实是自杀式计划，威胁三体人，只要你敢过来，我就炸水星，那地球也完蛋了。</p><p>经济学家诺斯说过一句话，一个系统里制度的建立，不是由双方的强弱关系来决定的，而是双方的谈判能力来决定的。这个战术的逻辑就是，我是打不过你，但只要我有毁掉你想要的东西的能力，那我就有谈判筹码。</p><p>然而，三体人把这个计划也识破了，而且三体人还是用的老办法，就是把你的计划公布到网上了。这次吃瓜群众的反对意见更大了，你这是想要把我们都杀了啊。结果，委内瑞拉总统在一次刚下飞机的时候，被一群愤怒的民众一拥而上，直接给打死了，第二个思想实验也以失败告终。</p><p>我们再来看看这个思想实验，面对外星人的入侵，我们应该对普通大众信息透明吗？按照小说的情节看，作者给的答案可能还真是否定的。前两个面壁者的计划，<br>虽然不是很完美，但是已经是大环境下最好的方案了。而吃瓜群众不了解啊，只要有一点对个人不利就会反对，不会把考虑上升到整个人类社会的。</p><p>所以，面对外星人的入侵，可能正确的方法是什么呢？还真的只能是把决定权交给少数人，给他极大的权力，甚至决定哪些人能活，哪些人必须牺牲。</p><p>我们再来看第三个面壁者。</p><p><strong>第三个面壁者，是欧盟主席</strong>。他拿出的计划叫——「思维钢印」。他的表面上的计划呢，是要研发一种叫思维钢印的机器，这种机器可以在人的大脑里强制性地输入观念。他是要给人类士兵都输入一个信念，就是：「在对三体的战争里，人类必胜」那这么一来，就能得到一群魂斗罗一样的战士。当然，这只是幌子，其实他的真实计划是，在输入信念的时候，偷偷往思想代码里加一个负号，这样一来结果就是完全反了，就从人类绝对能够胜利，变成人类绝对会失败了。</p><p>这个计划说白了就是留住火种的计划。俗话说，留得青山在，不怕没柴烧。因为他认为，人类肯定是打不过的三体人的，还不如保留人力。为什么说这个计划失败了呢，因为三体人根本不在乎，一百个魂斗罗的人类战士也打不过一个三体人，所以也懒得管他。所以第三个面壁者基本上也是失败告终。</p><p>那我们来看看第四位面壁者，也就是第二部小说的主人公罗辑。罗辑就是普通人一个，但是他也是唯一一个三体人希望除掉的人。唯一一个可能的原因，就是罗辑是叶文洁女儿的高中同学，罗辑曾经见过叶文洁一面。那次俩人见面一共就聊了半小时，但说了什么，人类不方便问，因为智子都听着呢，所以，人类就希望，但愿是什么特别厉害的信息吧，所以就让罗辑当了面壁者。</p><p>这天，罗辑终于干了一个看起来像面壁者该干的事儿。他让人类公布了一个宇宙里恒星系的位置，公布的方式是，公布了这颗恒星和其他恒星系的相对位置，比如，离 A 恒星多远，B 恒星多远，如果有一个高级文明拥有宇宙三维立体全景图，就可以用这些信息到全景图里去进行大数据的匹配，就能筛选出这组信息说的是哪个恒星系。发完这个信息之后，罗辑预测说，这个恒星星系在未来会遭到毁灭性的打击。虽然所有人都觉得莫名其妙，但还是照着做了。罗辑干完这件事，就说他没啥要做的了，他要申请冬眠了。当时人类掌握了冬眠技术，罗辑说那个恒星什么时候爆炸了，什么时候叫醒他。</p><p>以上就是四个面壁者的情况。接下来，我们就进入下一个思想实验。</p><p><br></p><h3 id="实验六"><a href="#实验六" class="headerlink" title="实验六"></a><strong>实验六</strong></h3><p><strong>如果面对外星人的侵略，我们应该采取什么样的社会架构来应对？</strong></p><p>我们先来看小说里的故事是怎么发展的。就在罗辑冬眠后，人类从哈勃望远镜看到在太阳系和三体人之间的恒星系之间，出现了 1000 多条整整齐齐的飞船尾迹。这下人类看到三体人真的来了。以此社会一下达成了共识。一旦形成共识，就会导出极权政府的回归。</p><p>在文化上，政府开始管控文化。在经济上，就会开始推行平均主义，放弃自然经济，最后干脆使用配给制，粮食、物资全都由政府配给。结果，这样的政治体制和经济政策，带来一个结果，就是三体人还没来呢，人类社会自己先崩溃了。人类进入了一个叫大低谷的时代，先是经济崩溃了，各地银行出现挤兑潮，后来很多国家的政府宣布破产，结果一发不可收拾，各地进入无政府状态了。人类进入了一个从来没有过的黑暗时期，整整 50 年，地球变成了地狱，到处都是人吃人，暴徒横行，世界人口从 83 亿降到了 35 亿，死了 50 亿人啊。</p><p>后来在大低谷的尾声，也就是 2080 年左右，人类世界开始触底反弹了，爆发了第二次启蒙运动，第二次文艺复兴。这次人类提出了一句掷地有声的口号，叫：「给岁月以文明，而不是给文明以岁月」大概的意思是，宁可像一个人一样被三体人灭掉，也不能像蚂蚁一样苟活着。</p><p>人类想明白这些之后，各国也都不搞集中生产了，也不教民众怎么做人了，每个人的心情都是，别跟我说什么战胜三体人这些没用的，过好眼前的小日子才是要紧的。</p><p>没想到，因为个体的解放，自由交易的恢复，整个社会的活力反而给调动起来了，全世界的经济也振兴了。经济一好，各种科技水准也追上来了。当然，智子还在上面封着人类理论物理的天花板，但是不影响各种应用技术突飞猛进。在接下来的这 100 年时间里，人类的文明蹭地一下就又站起来了，而且还反超了之前的科技水平。那我们是不是应该研发一下战舰呢，试着打一打呢？结果，人类这一研究，就彻底厉害了，反而有了捍卫地球的信心了。关于人类的武器怎么厉害，等一会我们再说。我们先来看一下人类的这次经济和科技的振兴。其实也很好理解，政治上松绑，自然给经济释放了活力，经济繁荣之后，科技当然也就突飞猛进了。</p><p>我们来做一个假设，如果三体人到达地球的时间不是 400 年，而是 4 年，那之前人类的做法可能情有可原，比如经济上施行配给制，军事上甚至强征公民入伍。当然可能结果还是打不赢，这么做是在短期内，能快速提升人类这个种族的战斗力的。因为在 4 年内迎战敌人，这个任务是一个「短期单一任务」，通过这样的社会资源配给方式，就可以最快地实现，而且会非常有效。</p><p>但是，如果任务是在 400 年的时间里，实现富国强兵，打败一个我们还没见过的敌人。那这就是一个标准的「长期复杂任务」，那怎么应对这种任务呢？其实还是那个最简单的方法——激发市场和社会的活力。目前人类找到的有效方式，就是让每一个人类个体自由地表达天性，想唱歌的唱歌，想娱乐的娱乐，把每个人的需求都卷入到社会协作里，这个社会才可能有科技上的创新。</p><p>举个例子，怎么能造出更好的战舰，不是让每一个人去做科研，而是尊重每个人的需求，只有每个人都想要一台更薄更时尚的手机的时候，商人们才有动力去生产更薄的芯片，那我们的宇宙飞船才能用上更薄的，经过市场检验的好芯片。这个做法可能在一开始是有点反直觉的。但在小说里，我们看到，就是因为人类先用生理反应代替了理性选择，才绕了那么大一个弯路的。</p><p>所以，我们第 6 个思想实验，如果面对外星人的侵略，我们应该采取什么样的社会架构来应对？小说里给的回答是，这个问题不好说，必须先反问一个问题，这个外星人到底什么时候来呢？</p><p>最后，我们来看一下人类战舰有多厉害。</p><p>人类的主战武器，叫恒星级飞船，是一种可以进行星际航行的超级战舰，长度大概是几百米，每艘战舰有 2000 多名船员，飞船可以以 15% 的光速前进，这个速度是超过了三体人的舰队的。人类战舰使用核聚变原料，总部在人类木星基地，舰队的机动性很强，完全可以驶出太阳系，到外层空间里截击三体舰队。恒星级战舰有可怕的破坏力。 这种恒星级战舰，已经服役的有 2015 艘，人类还在继续生产。而且，再反观三体人那边，明显已经不行了。人类一直在监视三体舰队，发现他们在穿过下一片星云物质的时候，舰队的数量已经从 1000 艘下降到 300 艘左右了，而且舰队的队形非常零散，非常混乱。这支破败的舰队将在 200 年后到达地球，如果它们还敢来的话，一定是来挨揍的。</p><p>到这里，「三体 2 ·黑暗森林」的上半部分，就结束了。在「三体 2 ·黑暗森林」的下半部分，三体人的一支小分队将光临太阳系，人类将和三体发生第一次交战。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>《三体》中的思想实验(一)：地球往事</title>
      <link href="/2018/10/07/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E4%B8%AD%E7%9A%84%E6%80%9D%E6%83%B3%E5%AE%9E%E9%AA%8C(%E4%B8%80)%EF%BC%9A%E5%9C%B0%E7%90%83%E5%BE%80%E4%BA%8B/"/>
      <content type="html"><![CDATA[<p>前些天在 <a href="https://t.zsxq.com/iuvrbeQ" target="_blank" rel="noopener">帅张的知识星球</a> 上看到一位球友发的几篇关于小说《三体》的文章，觉得十分有趣，特意寻求授权转载到自己的博客中，他欣然答应，在这里对这位球友表示感谢。以下是文章正文内容：</p><a id="more"></a><blockquote><p>原文作者：<a href="https://t.zsxq.com/62fIaU7" target="_blank" rel="noopener">Daotin</a></p></blockquote><p><img src="/2018/10/07/《三体》中的思想实验(一)：地球往事/banner.jpg" alt="Alt text"></p><p><br></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>最近在的得到听书上听完了怀沙解读刘慈欣的科幻巨著三部曲《三体》，非常震撼，不仅对作者的脑洞之大震惊之外，也对作者对科学的严谨态度叹服。</p><p>整个文章故事情节跌宕起伏，扣人心弦。主要内容讲的是：对人性绝望的天文学家叶文杰以太阳为放大器，向宇宙发射代表文明的信号，被临近星系的三体人截获，引发了三体人对地球的侵略之心。整本书不就是非常棒的科幻小说，书间夹杂着 15 个思想实验，更让整部小说的思想有了更高的深度，并引发了一系列人类对未来的思考，以及在面临人类灭绝时候如何去做才是最正确的选择。</p><p>这里我主要说说那 15 个思想实验所引发的人类的思考，至于故事情节自己去读小说好了，或者也像我一样偷懒直接去听别人讲的就行。可能有人会反驳说听书就相当于吃人嘴里的饭，这里我就不和你争论这个话题了。</p><p>说思想实验之前先看看三体小说的作者刘慈欣，他是一名高级工程师，科幻作者，被誉为「中国当代科幻第一人」。自上世纪 90 年代起，他一边在发电厂担任计算机工程师，一边利用业余时间写小说，连续多年获得中国科幻文学最高奖银河奖。2015 年获得被誉为科幻界的诺贝尔奖——雨果奖，这也是亚洲第一个获得此奖项的人。</p><p>有人这样评价刘慈欣：</p><blockquote><p>刘慈欣对于中国科幻，就如同姚明对于中国篮球<br>刘慈欣凭借一己之力将中国科幻提高到了世界级水平</p></blockquote><p>然后我们再看看小说部分，它分为三个部分，<strong>《三体》</strong>，<strong>《三体II：黑暗森林》</strong>，<strong>《三体III：死神永生》</strong>，主要讲述一个名叫”三体”的外星生命和地球生命之间的交流，博弈，争夺和厮杀，到最后各自兴衰的故事。</p><p>既然小说分为三部分，那么我也分三篇文章分别描述这三部曲的大致内容，重点是讲述这三篇文章的思想实验，我觉得它对人类的反思，对社会的进步具有非常大的教育意义。</p><p><br></p><h3 id="故事前提"><a href="#故事前提" class="headerlink" title="故事前提"></a><strong>故事前提</strong></h3><p>故事发生在文革时期，主人翁叫叶文杰，是一位天文物理学家，父母都在文革时代被迫害至死，于是叶文杰就产生了厌世心态，而她又是个天文物理学家，就有向宇宙发送信号的机会，于是她就把地球的大致情况发射向了宇宙。</p><p>而在距离地球 4 光年的地方，有一个叫三体的文明，他们的居住环境非常差，有三颗无规则运行的太阳主导下，他们的星球经历百余次毁灭与重生，这使得他们迫切想要找到一个合适的星球进行居住，于是他们就派了许多人不停监听来自宇宙的信号，而正好他们听到了叶文杰发来的地球信息。</p><p>收到叶文杰发来信息的是一个叫 1379 的三体人，说来也很搞笑，这个 1379 三体人在三体的文明中地位如此十分低下的，差不多类似于我们基层公务员的地位，还是个单身狗，岁数也不小了，于是他也产生了厌世情结，于是他就回复叶文杰，连说了三遍不要回复，你们那个方向上有许多星球。如果你不回复的话。我们是不能够定位你的位置。如果你回复的话，我们一定会侵略你们的，说完就向地球方向发射出去。</p><p>叶文杰收到消息后也特别诧异，没想到外星球上也有这么不靠谱的人。但是叶文洁还是回复消息说，来侵略我们吧。于是就啪的一下把消息发送给三体的方向。</p><p>在三体星球那边，1379 把消息发送之后就被抓了起来。当三体人再次接受到叶文杰的消息之后，欣喜若狂，就把星球的全部资源用来造星际战舰上面，然后浩浩荡荡的向地球前进。于是下面就引出第一个思想实验：</p><p><br></p><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a><strong>实验一</strong></h3><p><strong>在信息时代，一个普通个体，能在多大程度上破坏系统？</strong></p><p>我们知道在以前，一个普通人是绝对不可能对一个系统造成破坏的，除非你是类似于像吴三桂这样的人物。但是在信息时代，这种情况就是完全有可能的。叶文杰和 1379 ，就在类似于像聊天儿一样就把两个文明系统的生存与毁灭翻了两三遍。所以在信息时代，千万不要随便暴露自己的位置。霍金在 2015 年的时候也说过，千万不要回任何外星球发来的信息，因为一旦暴露位置可能对整个星球造成毁灭打击。</p><p>前面不是说到了嘛，三体人全副武装杀气腾腾的向地球进军，但是有一个问题就是三体人的飞船速度没有那么快，只有光速的百分之一，那么如果飞到地球需要 400 年，那么三体人就需要考虑 400 年后，地球的科技会发展到什么程度？于是三体人就回顾了下人类的科技历史，吓了一大跳。就近代热武器到核武器就几十年的时间，如果 400 年那就不是超过我们的问题，而是超过多少的问题。那怎么办呢，怎么遏制地球科技的发展呢？于是就引出了第二个思想实验：</p><p><br></p><h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a><strong>实验二</strong></h3><p><strong>我们知道打蛇要打七寸，那打一个文明的「七寸」，应该打什么地方？</strong></p><p>小说直接给出了答案：如果打一个文明的七寸，就是科技，再具体一点，是基础科学。</p><p>为什么这么说呢？在近代，人类的探索方向，主要极化为的两个方向，一个是极大，一个是极小。极大靠望远镜，极小靠对撞机。望远镜看什么呢？说的直白点就是看热闹，什么超行星爆炸，黑洞互撞等等。看到了之后怎么分析呢？就是靠对撞机，来分析粒子的特性。而分析粒子的特性，就是基础科学。所以三体人要打的就是人类的对撞机。</p><p>三体人派出了一个叫智子的东西来封锁住人类科学，智子非常高大上，它是三体人在九维空间制造的超小机器人然后折叠到三维空间，智子的速度能达到光速，所以只需要 4 年就可以达到地理。智子能干扰粒子对撞机，制造大量的假信息，破坏人类对微观世界的继续探索。对撞机无法工作，人类基础科学的探索就被封上了一层天花板。所以再说一次：一个文明的七寸，就是科技，再具体一点，是基础科学。</p><p>我们接着回到小说情节上，叶文杰除了向三体发送地球信息外，还干了很多坏事，还组建了一个地球叛军的组织，这个叛军组织买了一搜游轮就在海上办公，从不靠岸，就和三体人联系如何入侵地球。然后天下没有不透风的墙，这件事还是被地球的高层知道了，但是该如何处理这些叛徒呢？下面就引出了第三个思想实验：</p><p><br></p><h3 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a><strong>实验三</strong></h3><p><strong>一旦发现系统出现叛徒，最应该做的事情是什么？</strong></p><p>小说也给出了答案，就是要获取叛徒和对手的聊天记录。从聊天记录中，不仅可以更加客观的了解自己的弱点，也能知道对手想抢占的要点，而对手想要抢占的要点就是你要抢占的要点。</p><p>那么该如何获取叛徒的聊天记录呢？直接强攻肯定是不行的，这些叛徒可都是亡命之徒，随时可能删聊天记录的。把船炸掉也是不行的可能电脑硬盘都直接烧毁了。那么怎么办呢？人类发现了一个特别好的机会，那就是这叛军会在某一天经过巴拿马运河。巴拿马运河最窄地方只有几十米，就像一条河的宽度一样，在巴拿马运河的两岸树两个杆子，杆子中间拉许多纳米级的超韧性细丝，这些细丝非常锋利，就像切香肠一样能把船切成 50cm 的一段儿，一段儿的。那么可能有人会想，会不会把电脑硬盘给切坏了呢？其实没关系，因为切面非常的整齐，是可以恢复数据的。这次实验的结果非常成功。人们在船的废墟中找到了珍贵的聊天记录硬盘，一共有 27g 大小。</p><p>在这些聊天记录文件中，一共有两个消息非常重要，一个是大大的坏消息，一个是小小的好消息。大大的坏消息就是三体人向地球发射的智子，不仅能够破坏对撞机，而且还是个全天候，无死角，多线程的监视器，能够监视地球上每一个人的每一句话。那么人类对三体人的任何决策，三体人都能够立即了解，就像是直播一样，这个消息太重要的，否则人类的一切决断都暴露在三体人面前。小小的好消息就是三体人非常惧怕地球上的一个人，叫做罗辑。但是人类并不知道为什么三体人惧怕他，于是就找到罗辑，发现他其实只是一个普通人。但是不管了，敌人的要素就是我们得要素，于是就密切观察着罗辑的日常生活。</p><p>到这里，整个三体的第一部分就到此结束。我们来看看现在的天下状态：三体大军浩浩荡荡气势汹汹的朝地球进军，大概还有 400 年时间到达地球。他们还派出了智子来封锁我们的基础科技、监听我们的对话，而我们对他们一无所知。</p><p>那么这个仗该如何打呢？</p><p>请看三体第二部《三体II：黑暗森林》</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>数据结构与算法：复杂度分析</title>
      <link href="/2018/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<p><img src="/2018/10/03/数据结构与算法之美-复杂度分析/1.jpg" alt="Alt text"></p><p>数据结构与算法本身是为了让代码运行得更快，更省存储空间；那么如何考量一个算法的执行效率？这里就要用到时间、空间复杂度分析。<br><a id="more"></a><br><br></p><h3 id="一、为什么需要复杂度分析"><a href="#一、为什么需要复杂度分析" class="headerlink" title="一、为什么需要复杂度分析"></a>一、为什么需要复杂度分析</h3><p>有人会觉得把代码放在实际环境中测试一遍，对结果进行统计和监控就能得到算法准确的执行效率，因此不需要对代码做时间和空间复杂度分析，但其实这种分析方法带有一定的局限性。</p><p><strong>首先，测试结果非常依赖测试环境</strong>，用同一段代码在不同性能的处理器上运行，性能高的处理器的执行速度肯定要比性能低的速度快；在不同的机器上，两段不同的代码执行速度的比较也会有所差别。因此测试环境中硬件的不同会对测试结果有很多的影响。</p><p><strong>其次，测试结果受数据规模的影响很大</strong>，拿排序算法举例，假如输入进一个排序算法的数据是有序的，那么排序算法便不需要做任何操作，执行时间便会非常短；除此之外，对于同一个算法，算法的数据规模不一样，执行时间会有很大的差别，数据规模太小可能无法反应算法的真实性能，比如对于小规模的数据排序，插入排序可能会比快速排序要快得多。</p><p>因此我们需要一种不用具体数据来测试，就能粗略估计算法执行效率的方法，所以我们才要对算法进行时间和空间复杂度分析。</p><p><br></p><h3 id="二、大O复杂度表示法"><a href="#二、大O复杂度表示法" class="headerlink" title="二、大O复杂度表示法"></a>二、大O复杂度表示法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt;= n; ++i) &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码是求 1 到 n 累加的和，我们假设每一行代码的执行时间都一样，为 time ，那么第 2、3 行代码分别需要 1 个 time 的执行时间，而第 4、5 行都运行了 n 遍 ，需要 <code>2n*time</code> ，假设这段代码的执行时间为 T(n) ，我们可以粗略估计这段代码运行需要 <code>T(n)=(2n+2)*time</code> 的执行时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">        j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">            sum = sum + i * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照刚才的假设，这段代码中第 7、8 行代码循环了 n² 遍，因此代码的总执行时间为 <code>T(n)=(2n²+2n+3)*time</code>，尽管不知道 time 的具体值，我们也能得出，<strong>代码的执行时间 T(n) 与每行代码的执行次数 n 成正比</strong>。</p><p>用大O复杂度表示如下:</p><p><img src="/2018/10/03/数据结构与算法之美-复杂度分析/2.jpg" alt="Alt text"></p><blockquote><p>其中 T(n) 表示代码执行时间，n 表示数据的规模，f(n) 表示每行代码的执行次数总和（如上述的 2n+3 ），O 表示代码执行时间 T(n) 与 f(n) 表达式成正比。</p></blockquote><p>由于是粗略估计，<strong>当公式中的 n 很大时，公式中的 低阶、常量、系数都不会左右它的增长趋势，因此我们可以把它们忽略</strong>，只需记录一个最大的量级，如上面两端代码的时间复杂度就可以记为 <code>T(n)=O(n)</code>；<code>T(n)=O(n²)</code> 。</p><p><br></p><h3 id="三、时间复杂度分析"><a href="#三、时间复杂度分析" class="headerlink" title="三、时间复杂度分析"></a>三、时间复杂度分析</h3><p>对代码进行时间复杂度分析有三种方法：</p><p><strong>1. 关注执行次数最多的那一行代码</strong></p><p>由于公式中的 低阶、常量、系数 对大 O 的影响不大，因此在分析代码的时间复杂度的时候我们只需记录最大阶的量级就可以了，即执行次数最多的代码段。</p><p>像上面第一段代码中，执行次数最多的是第 4、5 行代码，这两段代码都被执行了 n 次，因此时间复杂度为 O(n)；第二段代码的 O(n²) 也是一个道理。</p><p><strong>2. 加法法则：总复杂度等于量级最大的那段代码的复杂度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>,p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">        sum1 = sum1 + p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum2 = <span class="number">0</span>,q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; q &lt; n; ++q) &#123;</span><br><span class="line">        sum2 = sum2 + q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum3 = <span class="number">0</span>,i = <span class="number">1</span>,j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt;=n; ++j) &#123;</span><br><span class="line">            sum3 = sum3 + i*j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum1 + sum2 + sum3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码分为三个部分，sum1 ，sum2 ，和 sum3 ，从之前的结论可以得出这三段代码的复杂度分别为 O(1) ；O(n) ；O(n²)。我们取其中最大的量级，整段代码的时间复杂度便为 O(n²) 。因此说 <strong>总的时间复杂度等于量级最大的那段代码的复杂度</strong> 。用公式表示为：</p><blockquote><p>T1(n) = O(f(n)) ，T2(n) = O(g(n))<br>T(n) = T1(n) + T2(n) = Max ( O(f(n)) , O(g(n)) ) = O( Max( f(n) , g(n) ) ) </p></blockquote><p><strong>3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">        ret = ret + f(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类比加法法则，乘法法则的公式是这样的:</p><blockquote><p>T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O( ( f(n) * g(n) ) </p></blockquote><p>上面代码中，由于 f() 被嵌套在了 cal() ，而 f(n) 的时间复杂度为 O(n) ，因此套用刚才的结论和公式可以得到整个 cal() 的时间复杂度为 <code>O(n²)</code>。</p><p><br></p><h3 id="四、几种常见时间复杂度分析"><a href="#四、几种常见时间复杂度分析" class="headerlink" title="四、几种常见时间复杂度分析"></a>四、几种常见时间复杂度分析</h3><p><img src="/2018/10/03/数据结构与算法之美-复杂度分析/3.jpg" alt="Alt text"></p><p>常用的复杂度量级有以上几个，他们可以粗略地分为 <strong>多项式量级</strong> 和 <strong>非多项式量级</strong></p><h4 id="非多项式量级"><a href="#非多项式量级" class="headerlink" title="非多项式量级"></a><strong>非多项式量级</strong></h4><p><strong>非多项式量级</strong>只有两个 <strong>O(2<sup>n</sup>)</strong> 和 <strong>O(n!)</strong>。<br>非多项式量级的算法有一个特点，当 n 的规模越来越大时，非多项式量级的算法的执行时间会急剧增加，求解问题的执行时间也会无限增长，因此<strong>非多项式量级的算法是非常低效的算法</strong>。<strong>一般把非多项式量级的算法问题叫做非确定多项式问题</strong>。</p><h4 id="多项式量级"><a href="#多项式量级" class="headerlink" title="多项式量级"></a><strong>多项式量级</strong></h4><p><strong>1. O(1)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum = i + j;</span><br></pre></td></tr></table></figure><p>O(1) 是常量级时间复杂度的一种表示方法；<strong>只要代码的执行时间不随着 n 规模的增大而增长，或者说代码中没有循环或递归语句，那么其时间复杂度都是 O(1)</strong> 。</p><p><strong>2. O(logn) 、 O(nlogn)</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中第 3 行执行的次数最多，且每循环一次就乘以 2 ，实际上这就是一个等比数列<br><img src="/2018/10/03/数据结构与算法之美-复杂度分析/4.jpg" alt="Alt text">我们如果求出 x 的值就能知道代码的执行次数，2<sup>x</sup> = n ，所以 x = log<sub>2</sub>n ，所以这段代码的时间复杂度就是 O(log<sub>2</sub>n)。<strong>实际上不论以 2 为底还是其他数字，我们都把所有对数阶的时间复杂度写成 O(logn)；因为对数之间是可以互相转换的。</strong></p><p>将上述时间复杂度为 O(logn) 的代码循环执行 n 遍，它的时间复杂度便为 O(nlogn)；这两种都是很常见的算法的时间复杂度，如归并排序和快速排序。</p><p><strong>3. O(m+n) 、O(m*n)</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">        sum1 = sum1 + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">        sum2 = sum2 + j</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，m 和 n 是表示两个数据规模，不能用简单的加法规则省略掉其中一个，因此上面代码的时间复杂度为 O(m+n)；但有不同数据规模时乘法法则依然有效。</p><p><br></p><h3 id="五、空间复杂度分析"><a href="#五、空间复杂度分析" class="headerlink" title="五、空间复杂度分析"></a>五、空间复杂度分析</h3><p>时间复杂度全称是 <strong>渐进时间复杂度</strong>，表示 <strong>算法的执行时间与数据规模之间的增长关系</strong>。类比一下，空间复杂度的全程就是 <strong>渐进空间复杂度</strong>，它表示 <strong>算法的存储空间与数据规模之间的增长关系</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (i; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">        print out a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟时间复杂度一样，上面代码中第 2 行申请了一个空间存储变量 i ，但是是常量阶的，可以忽略，第 3 行申请了一个大小为 n 的数组，除此之外的代码都没有占用更多的空间，因此整段代码的空间复杂度便为 O(n)。</p><p>常见的空间复杂度为 O(1) 、 O(n) 、O(n²)，像 O(logn) 和 O(nlogn) 的平时是比较少见的。</p><p><br></p><h3 id="六、最好、最坏情况时间复杂度"><a href="#六、最好、最坏情况时间复杂度" class="headerlink" title="六、最好、最坏情况时间复杂度"></a>六、最好、最坏情况时间复杂度</h3><p>试想一个有 n 个元素的数组，我们要在这个数组中找到元素 x 的位置<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照我们之前的说法，很容易就能看出这段代码的时间复杂度为 O(n)，但是我们在数组中查找元素时，并不需要把整个数组全部遍历一遍，我们姚找的那个元素可能出现在数组的任意位置。假如元素 x 在数组的第一个位置，那么时间复杂度就是 O(1)，若是在数组的最后一位，那么时间复杂度就为 O(n)。因此不同情况下，这段代码的时间复杂度是不一样的，所以我们引入两个概念：<strong>「最好情况时间复杂度」</strong>和 <strong>「最坏情况时间复杂度」</strong> 。</p><p>按照刚才的情况，在最理想的情况下，要查找的元素正好是数组的第一个元素，这时对应的时间复杂度就是最好情况时间复杂度。同理，在最糟糕的情况下，也就是元素不在数组中或者刚好在数组最后一位，这时的时间复杂度就是最坏情况时间复杂度。</p><p><br></p><h3 id="七、平均情况时间复杂度"><a href="#七、平均情况时间复杂度" class="headerlink" title="七、平均情况时间复杂度"></a>七、平均情况时间复杂度</h3><p>最好和最坏情况时间复杂度都是在极端情况下的发生的，为了更好的表示平均情况下的复杂度，我们就需要引入 <strong>「平均情况时间复杂度」</strong>。</p><p>在刚才查找元素 x 的过程中，共有 n+1 种情况：在数组 0 ~ n-1 位置中和不在数组中，把每种情况下查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，</p><p>得到最后结果为 O(n)。<br>很多时候我们并不用区分这最好、最坏、平均这三个复杂度，只需使用一个复杂度就可以满足需求。只有同一块代码在不同的情况下，时间复杂度有量级的差距的时候才会用这三种表示方法来区分。</p><p><br></p><h3 id="八、均摊时间复杂度"><a href="#八、均摊时间复杂度" class="headerlink" title="八、均摊时间复杂度"></a>八、均摊时间复杂度</h3><p>在平均情况时间复杂度的基础上引入一种更简单的分析方法：「摊还分析法」，通过摊还分析得到的时间复杂度，就叫 <strong>「均摊时间复杂度」</strong>。<br>用一个例子来使用摊还分析法去分析算法的均摊时间复杂度：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array 表示一个长度为 n 的数组</span></span><br><span class="line"><span class="comment">// 代码中的 array.length 就等于 n</span></span><br><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count == <span class="built_in">array</span>.length) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; ++i) &#123;</span><br><span class="line">         sum = sum + <span class="built_in">array</span>[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">array</span>[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">array</span>[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一段实现往数组中插入数据的代码，一开始往数组中插入数据，当数组中空间满了之后，会执行一次 for 循环，将数组里的元素加起来并清空数组，并将数组的和放在数组中的第一个位置。分析之后可以知道每执行 n-1 次 O(1)的插入之后都会执行一次 O(n) 的数据插入。</p><p>如果我们把耗时多的那次操作，即数组空间满了之后的 O(n) 操作，均摊到 n-1 次耗时少的操作上，均摊下来，这一组连续插入操作的均摊时间复杂度就是 O(1) 。这就是均摊分析的大致思路。</p><p><br></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>分析下面代码的最好、最坏、平均/均摊时间复杂度：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，大小为 10 的数组 array，长度 len，下标 i。</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &gt;= len) &#123; <span class="comment">// 数组空间不够了</span></span><br><span class="line">     <span class="comment">// 重新申请一个 2 倍大小的数组空间</span></span><br><span class="line">     <span class="keyword">int</span> new_array[] = <span class="keyword">new</span> <span class="keyword">int</span>[len*<span class="number">2</span>];</span><br><span class="line">     <span class="comment">// 把原来 array 数组中的数据依次 copy 到 new_array</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">       new_array[j] = <span class="built_in">array</span>[j];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// new_array 复制给 array，array 现在大小就是 2 倍 len 了</span></span><br><span class="line">     <span class="built_in">array</span> = new_array;</span><br><span class="line">     len = <span class="number">2</span> * len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将 element 放到下标为 i 的位置，下标 i 加一</span></span><br><span class="line">   <span class="built_in">array</span>[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解答：</p><blockquote><p>当i &lt; len时, 即 i = 0,1,2,…,n-1的时候，for循环不走，所以这n次的时间复杂度都是O(1);<br>当i &gt;= len时, 即 i = n的时候，for循环进行数组的copy，所以只有这1次的时间复杂度是O(n);<br>由此可知:<br>该算法的最好情况时间复杂度为 O(1)；最坏情况时间复杂度为 O(n)。<br>平均情况时间复杂度：<br>第一种计算方式: (1+1+…+1+n)/(n+1) = 2n/(n+1) 【注: 式子中1+1+…+1中有n个1】,所以平均复杂度为O(1);<br>第二种计算方式(加权平均法，又称期望): 1<em>(1/n+1)+1</em>(1/n+1)+…+1<em>(1/n+1)+n</em>(1/(n+1))=1，所以加权平均时间复杂度为O(1);<br>第三种计算方式(均摊时间复杂度): 前n个操作复杂度都是O(1)，第n+1次操作的复杂度是O(n)，所以把最后一次的复杂度分摊到前n次上，那么均摊下来每次操作的复杂度为O(1)</p></blockquote><p><br></p>]]></content>
      
      
        <tags>
            
            <tag> 数据结构与算法之美 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS设计指南：定位元素(一)</title>
      <link href="/2018/09/23/CSS%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0(%E4%B8%80)/"/>
      <content type="html"><![CDATA[<p>CSS定位元素<br><a id="more"></a></p><h2 id="定位元素-一"><a href="#定位元素-一" class="headerlink" title="定位元素(一)"></a>定位元素(一)</h2><p><br></p><h3 id="一、-理解盒子模型"><a href="#一、-理解盒子模型" class="headerlink" title="一、 理解盒子模型"></a><strong>一、 理解盒子模型</strong></h3><blockquote><p>每一个元素都会在页面上生成一个盒子，HTML页面实际上就是由一堆盒子组成的，默认情况下，每个盒子的边框都不可见，背景也是透明的。</p></blockquote><p>那么，盒模型有哪些属性呢，总的来说盒子的属性可分为三组：</p><ul><li><strong>border（边框）</strong> 可以设置边框的宽窄、样式和颜色</li><li><strong>padding（内边距）</strong>可以设置盒子内容区与边框的间距</li><li><strong>margin（外边距）</strong>可以设置盒子与相邻元素的间距</li></ul><p>一个盒子模型如下图所示<br><img src="/2018/09/23/CSS定位元素(一)/1531904043318.png" alt="Alt text"></p><p><br></p><h4 id="1-盒子边框（border）"><a href="#1-盒子边框（border）" class="headerlink" title="1. 盒子边框（border）"></a><strong>1. 盒子边框（border）</strong></h4><p>盒子边框有 3 个相关属性</p><ul><li><strong>boder-width</strong> 可以使用 thin、medium、thick等文本值，也可以使用除百分比和负值之外的任何绝对值。</li><li><strong>border-style</strong> 有none、hidden、dotted<code>(虚线)</code>、dashed、solid、double<code>（双实线）</code>、groove、ridge、inset、outset<code>（这四个是边框的内凹外凹）</code>等值。</li><li><strong>border-color</strong> 可以使用包括 RGB 、HSL 在内的任意颜色值和关键字。</li></ul><p>其中boder-width 、border-style 的值在不同浏览器中的显示可能有所不同。</p><p>默认情况下，边框的三个属性值分别为：</p><ul><li>border-width : medium</li><li>border-style : none</li><li>border-color : black</li></ul><p>因此默认情况下不会显示盒子边框，开发中我们常常会临时设定盒子的边框，为了快速把盒子边框显示出来，我们可以应用这条规则<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123; border：solid 1px ; &#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-盒子的内边距-padding"><a href="#2-盒子的内边距-padding" class="headerlink" title="2. 盒子的内边距(padding)"></a><strong>2. 盒子的内边距(padding)</strong></h4><p><strong>内边距是盒子内容区与盒子边框之间的距离。</strong></p><p>这是没有加 padding 的 p 元素<br><img src="/2018/09/23/CSS定位元素(一)/1531905405176.png" alt="Alt text"></p><p>当我们给他加上 10px 的 padding 之后<br><img src="/2018/09/23/CSS定位元素(一)/1531905439854.png" alt="Alt text"></p><blockquote><p>注意，由于内边距在盒子的内部，所以padding也会取得盒子的背景<br>仔细两幅图可以发现，内边距实际加在了声明的盒子的宽度之上（后面解释）</p></blockquote><p><br></p><h4 id="3-盒子的外边距-margin"><a href="#3-盒子的外边距-margin" class="headerlink" title="3. 盒子的外边距(margin)"></a><strong>3. 盒子的外边距(margin)</strong></h4><p>我们举三组标题和段落来说明盒子的外边距</p><p><img src="/2018/09/23/CSS定位元素(一)/1531905920851.png" alt="Alt text"></p><p>第一组和第二组都使用默认的样式，而第二组跟第一组的区别就是多了边框，对比之后，我们可以看到浏览器给标题和段落都设定了默认的 margin 样式。第三组我设定了 margin : 0 ，可以看到该组的标题和段落全部紧挨在一起。<br>因此，建议大家在写网页的时候，把这条规则作为样式表的第一条规则:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这个也叫<strong>重置CSS样式</strong>，作用是为了将浏览器给元素添加的默认样式都清除。网上有很多重置样式表（如 reset.css），还对很多元素在跨浏览器显示时的外观进行了标准化，想了解更多可以自行百度“CSS重置”</p></blockquote><p>关于外边距需要注意的几点</p><ul><li><strong>垂直外边距会叠加</strong></li></ul><p>假设有三个段落，我们均设定<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">margin-top</span>:<span class="number">50px</span>; <span class="attribute">margin-bottom</span>:<span class="number">3</span>opx;&#125;</span><br></pre></td></tr></table></figure></p><p>你可能会认为每两个段落之间的间距是 50 + 30 = 80px ，这种认知错误的，实际上他们之间的间距是50px！</p><p><strong>像这样上下外边距相遇时，它们就会相互重叠，直至一个外边距碰到另一个元素的边框</strong>，第二段较宽的上外边距会碰到第一段的边框，<strong>也就是说，较宽的外边距决 定两个元素终离多远</strong>，这就叫做外边距的叠加。</p><p><strong>注意，只有垂直外边距会叠加，水平外边距并不会叠加。</strong>对于水平相邻的元素他们的水平间距是相邻外边距之和。<br><br></p><ul><li><strong>外边距的单位</strong></li></ul><blockquote><p>根据经验，为文本元素设置外边距时通常需要混合使用不同的单位。<br>比如说，一个段落的左、右外边距可以使用像素，以便该段文本始终与包含元素边界保持固定间 距，不受字号变大或变小的影响。而<strong>对于上、下外边距，以 em为单位则可以让段间 距随字号变化而相应增大或缩小。</strong></p></blockquote><p>比如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里使用了简写属性把上、下外边距设置为.75em，把左、右外边距设置为 30 像素*/</span> </span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">1em</span>; <span class="attribute">margin</span>:.<span class="number">75em</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure></p><p>这样，段落的垂直间距始终会保持为字体高度的四分之三（上下外边距都是.75em， 叠加后还是.75em）。如果用户增大了字号，那么不仅段落中的文本会变大，段间距也会成比例变大。这样，页面的整体布局就会比较协调一致。与此同时，使用像素 单位的左、右外边距不会改变。</p><hr><p><br></p><h3 id="二、-盒子的大小是如何变化的"><a href="#二、-盒子的大小是如何变化的" class="headerlink" title="二、 盒子的大小是如何变化的"></a><strong>二、 盒子的大小是如何变化的</strong></h3><p>接下来我们用两种盒子来说明盒子的具体大小是如何变化的。</p><ul><li><strong>一种是没有宽度的盒子</strong>，既没有设定 width 属性。</li><li><strong>另一种是带有宽度的盒子</strong>，我们设定 width ：400px<br><br></li></ul><h4 id="1-没有宽度的盒子"><a href="#1-没有宽度的盒子" class="headerlink" title="1. 没有宽度的盒子"></a><strong>1. 没有宽度的盒子</strong></h4><p>没有设定 width 属性的块级元素盒子，他的 width 属性默认值是 auto ，结果会让元素的宽度扩展到父元素同宽。<br>接下来我们给一个段落添加以下样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>:helvetica, arial, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">1em</span>; <span class="attribute">margin</span>:<span class="number">0px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#caebff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br><img src="/2018/09/23/CSS定位元素(一)/1531907921945.png" alt="Alt text"></p><p>可以看到，段落文本扩展到了body元素同宽。<br>接下来，我们给文本左右两侧添加内边距 padding：0 20px;<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531908385632.png" class="lazyload"></p><p>可以看到，添加了内边距之后，文本块的宽度会减少。<br>接下来，我们给文本左右两侧添加边框 border-width：0 6px 0 6px;<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531908426749.png" class="lazyload"></p><p>虽然不太明显，但实际上文本块的宽度又减少了。<br>最后，我们给左右两侧再加上外边距 margin：0 30px;<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531908625311.png" class="lazyload"></p><p>果不其然，文本块的宽度再一次减少</p><p>结论：</p><blockquote><p><strong>没有（就是没有设置 width 的）宽度的元素始终会扩展到填满其父元素的宽度为止。</strong>添加水平边框、内边距和外边距，会导致内容宽度减少，<strong>减少量等于水平边框、内边距和外边距的和</strong>。</p></blockquote><p><br></p><h4 id="2-带有宽度的盒子"><a href="#2-带有宽度的盒子" class="headerlink" title="2. 带有宽度的盒子"></a><strong>2. 带有宽度的盒子</strong></h4><p>我们再用和上面没有宽度的盒子一样的方法，来看看带有宽度的盒子的大小是怎样变化的。<br>给段落添加样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">ont-family</span>:helvetica, arial, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">1em</span>; <span class="attribute">margin</span>:<span class="number">0px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#caebff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">400px</span>; <span class="comment">/* 设定元素宽度为400px*/</span></span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/placeholder.png" alt="Alt text" data-src="./1531909206438.png" class="lazyload"></p><p>可以看到，明确设定 width 属性后，块级元素就不会再扩展到与父元素（即 body）同宽了。<br>一样的，我们添加 20px 的内边距<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531909251064.png" class="lazyload"></p><p><strong>这一次，文本块的的宽度并由变化，反而使的元素比原来宽了 40px</strong><br>一样的，我们再给元素添加 6px 的边框</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="./1531909406049.png" class="lazyload"></p><p>最后，添加外边距</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="./1531909487051.png" class="lazyload"></p><p>为此我们可以得出，带有宽度的盒子模型大小变化的结论：</p><blockquote><p>为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展得更宽。实际上，盒子的 width 属性设定的只是盒子内容区的宽度，而非盒子要占据的水平宽度。</p></blockquote><p>总之，关于盒子大小的变化，我们需要记住一点<br><strong>设定了元素的 width 属性后，再给元素添加边框、内边距和 外边距，元素的行为与默认的 auto 状态下会有截然不同的表现。</strong> </p><hr><p><br></p><h3 id="三、-浮动与清除-float-clear"><a href="#三、-浮动与清除-float-clear" class="headerlink" title="三、 浮动与清除(float clear)"></a><strong>三、 浮动与清除(float clear)</strong></h3><p><br></p><h4 id="1-浮动"><a href="#1-浮动" class="headerlink" title="1. 浮动"></a><strong>1. 浮动</strong></h4><p><strong>浮动，意思就是把元素从常规文档流中拿出来。</strong><br>当你浮动一个元素的时候……这个元素就好像在说：‘尽量把我往上放，能放多高放多高，直到碰到某个元素的边界为止。</p><p>浮动元素脱离了常规文档流之后，原来紧跟其后的元素就会在空间允许的情况下，向上提升到与浮动元素平起平坐。</p><blockquote><p>CSS 设计 float 属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属性也成了<strong>创建多栏布局简单的方式</strong>。</p></blockquote><p>让我们先从文本绕排图片这个例子来认识浮动吧！</p><p><strong>文本绕排图片</strong></p><p>示例代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">img&#123;</span></span><br><span class="line"><span class="undefined">margin: 0 4px 4px 0;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">p&#123;</span></span><br><span class="line"><span class="undefined">margin: 0;</span></span><br><span class="line"><span class="undefined">border: solid 1px red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"pic03.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>原始效果<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532009409141.png" class="lazyload"></p><p>可以看到处在常规文档流中的图片跟段落这两个块级元素竖直排列在一起。</p><p>接下来，我们要实现文字绕排文字效果了，怎么做呢？</p><p>就是让图片浮动起来，我们给图片添加以下样式 img { float:left }<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532009670827.png" class="lazyload"></p><p>解释：</p><blockquote><p>在你浮动一张图片或者其他元素时，你是在要求浏览器把它往上方推，直到它碰到父元素（也就是 body 元素）的内边界。<strong>后面的段落（带灰色边框） 不再认为浮动元素在文档流中位于它的前面了，因而它会占据父元素左上角的位置。</strong> 不过，它的内容（文本）会绕开浮动的图片。 </p></blockquote><p>注意：</p><blockquote><p>由于图片自身带有宽度，因此在浮动的时候无需设定宽度。然而在浮动非图片元素时，必须给非图片元素设定宽度，否则后果难以预料<br><br></p></blockquote><h4 id="2-围住浮动元素的三种方法"><a href="#2-围住浮动元素的三种方法" class="headerlink" title="2. 围住浮动元素的三种方法"></a><strong>2. 围住浮动元素的三种方法</strong></h4><p>上面我们讲到，当一个元素浮动后，他就脱离了文档流，因而它也不被包含在父元素之内了，因此它也可能会对布局产生破坏性的影响。那么，我们该怎么控制浮动的元素呢？</p><p>接下来介绍把浮动元素“控制住”的三种方法</p><p>示例代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">section &#123;</span></span><br><span class="line"><span class="undefined">margin: 0 0 10px 0;</span></span><br><span class="line"><span class="undefined">border: solid 1px red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">p &#123;</span></span><br><span class="line"><span class="undefined">margin: 0;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">footer&#123;</span></span><br><span class="line"><span class="undefined">border: solid 1px red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"pic03.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>It's fun to float<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet....<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>原始效果<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532010675831.png" class="lazyload"></p><p>现在，一切正常，所有元素自上而下堆叠在一起，接下来，我们让图片标题位于图片右侧，该怎么做呢？从上一节我们知道，就是让图片浮动起来。给图片添加 img { float: left}</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="./1532010876833.png" class="lazyload"></p><p>OK，现在图片标题以及在图片右侧啦。</p><p>但是我们也看到，<strong>由于图片浮动了，现在图片已经不在父元素section里面了，换句话说，图片脱离了常规文档流，这也就导致了父元素section收缩到了只包含文本高度的高度。</strong> 而且，footer元素也被提上来了，紧挨着前一个块级元素，这可不是我们想要的。</p><p>所以，我们必须得把浮动元素“控制住”。<br><br></p><h5 id="方法一：给浮动元素的父元素添加-overflow：hidden"><a href="#方法一：给浮动元素的父元素添加-overflow：hidden" class="headerlink" title="方法一：给浮动元素的父元素添加 overflow：hidden"></a><strong>方法一：给浮动元素的父元素添加 overflow：hidden</strong></h5><pre><code>overflow：hidden的用途&gt; overflow:hidden 原本是使包含元素依然保持其设定的宽度，而超过的子内容则会被容器剪切掉（不被显示），防止包含元素被超大内容撑大。&gt; **除此之外，overflow:hidden 还有另一个作用，即它能可靠地迫使父元素包含其浮动的子元素。**</code></pre><p>现在我们试试给父元素 section 加上overflow : hidden<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532011483647.png" class="lazyload"></p><p>确认过眼神，是我们想要的效果！footer回到了我们期望的位置<br><br></p><h5 id="方法二：同时浮动父元素"><a href="#方法二：同时浮动父元素" class="headerlink" title="方法二：同时浮动父元素"></a><strong>方法二：同时浮动父元素</strong></h5><p>促使父元素包围其浮动子元素的方法，是也让父元素也浮动起来。<br>来，我们先试试给 section 添加float：left，让父元素浮动起来</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="./1532011822780.png" class="lazyload"></p><p>结果跟我们想象中的不太一样呢，别急，回想一下我们之前的知识点，在浮动非图片元素时，我们得给他们加一个宽度对吧。那么，为什么呢？</p><p><strong>原因是，当我们浮动任何元素时，不管其是否有子元素，不管其子元素是否浮动，他都会紧紧地包裹住它的内容，或者是，它的子元素。</strong></p><p>那就好解决了，我们给 section 加一个宽度width：100%，让它和浏览器同宽就好了。<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532012223208.png" class="lazyload"></p><p>这效果是对了，但怎么看起来总觉得怪怪的呢？原来是footer给挤上去了！</p><p>再回想一下，当我们浮动了一个元素，原本紧跟其后的元素也会在空间允许的情况下不断地往上挤。因此，footer 也无一例外地努力挤到了 section 的旁边了。</p><p>那么，我们该怎样使得 footer 依然呆在 section 下方呢？<br>答案是给footer应用一个清除 clear：left ，这样被清除的元素就不会被提升到浮动元素的旁边。<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532012933309.png" class="lazyload"></p><p><br></p><h5 id="方法三：给父元素添加-clearfix-after-规则"><a href="#方法三：给父元素添加-clearfix-after-规则" class="headerlink" title="方法三：给父元素添加 .clearfix:after 规则"></a><strong>方法三：给父元素添加 .clearfix:after 规则</strong></h5><p>.clearfix:after 规则：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">"."</span>;</span><br><span class="line"><span class="attribute">display</span>:block;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">visibility</span>:hidden;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>说明：</p><blockquote><p>这个 .clearfix 规则只添加了一个清除的包含句点作为非浮动元素（必须得有内容，而句点是最小的内容）。规则中的其他声明是 为了确保这个伪元素没有高度，而且在页面上不可见。<br>使用 clear:both 意味着 section 中新增的子元素会清除左、右浮动元素（位于左、右浮 动元素下方）。这里当然可以只用 left，但 both 也适用于将来图片 float:right 的情况。</p></blockquote><p>给section元素添加类 class=”clearfix” ，我们可以得到跟上图一样的效果<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532012933309.png" class="lazyload"><br><br></p><h5 id="三种方法如何选择？"><a href="#三种方法如何选择？" class="headerlink" title="三种方法如何选择？"></a><strong>三种方法如何选择？</strong></h5><p>这三种方法的使用要因地制宜。</p><blockquote><p>比如，不能在下拉菜单的顶级元素上应用 overflow:hidden，否则作为其子元素的下拉菜单就不会显示了。因为下拉菜单会显示在其父元素区域的外部，而这恰恰是 overflow:hidden 所要阻止的。</p></blockquote><blockquote><p>再比如，不能对已经靠自动外边距居中的元素使用“浮动父元素”技术，否则它就不会再居中，而是根据浮动值浮动到左边或右边了。</p></blockquote><blockquote><p>推荐使用clearfix规则</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> CSS设计指南笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS设计指南：CSS选择器(二)</title>
      <link href="/2018/09/23/CSS%E9%80%89%E6%8B%A9%E5%99%A8(%E4%BA%8C)/"/>
      <content type="html"><![CDATA[<p>常用的CSS选择器(二)<br><a id="more"></a></p><h2 id="CSS选择器-二"><a href="#CSS选择器-二" class="headerlink" title="CSS选择器(二)"></a><strong>CSS选择器(二)</strong></h2><p><br></p><h3 id="4-属性名、属性值选择符"><a href="#4-属性名、属性值选择符" class="headerlink" title="4. 属性名、属性值选择符"></a>4. 属性名、属性值选择符</h3><p>所用示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">"yellow flower"</span> <span class="attr">alt</span>=<span class="string">"yellow flower"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">"blue flower"</span> <span class="attr">alt</span>=<span class="string">"blue flower"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1 . 属性名选择符</strong><br>用法：<strong>标签[属性名] { 声明 }</strong><br>例如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[title]</span> &#123;<span class="attribute">border</span>:<span class="number">3px</span> solid yellow;&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/23/CSS选择器(二)/1531730591644.png" alt="Alt text"></p><p><strong>2 . 属性值选择符</strong><br>用法： <strong>标签[属性名=”属性值”] {声明}</strong><br>例如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[title="red flower"]</span> &#123;<span class="attribute">border</span>:<span class="number">3px</span> solid blue;&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/23/CSS选择器(二)/1531730739166.png" alt="Alt text"></p><hr><p><br></p><h3 id="5-伪类"><a href="#5-伪类" class="headerlink" title="5. 伪类"></a>5. <strong>伪类</strong></h3><p>伪类这个叫法源自它们与类相似，但实际上并没有类会附加到标记中的标签上。伪类分两种。 </p><ul><li><strong>UI伪类</strong> 会在 HTML元素处于某个状态时（比如鼠标 指针位于链接上），为该元素应用 CSS样式。</li><li><strong>结构化伪类</strong> 会在标记中存在某种结构上的关系时（如某个元素是一组元素中的第 一个或后一个），为相应元素应用 CSS 样式。 </li></ul><p><br></p><h4 id="一-UI伪类"><a href="#一-UI伪类" class="headerlink" title="(一) UI伪类"></a><strong>(一) UI伪类</strong></h4><h5 id="1-链接伪类"><a href="#1-链接伪类" class="headerlink" title="1. 链接伪类"></a>1. 链接伪类</h5><ul><li><strong>:link</strong>      链接的默认状态</li><li><strong>:visited</strong>   用户点击过链接后的状态</li><li><strong>:hover</strong>     用户鼠标悬停在链接上的状态</li><li><strong>:active</strong>    链接正在被点击（鼠标还未释放）</li></ul><blockquote><p>如果不按上述顺序使用(不用四个全部使用)，浏览器可能不会显示预期的效果。<br>hover可以用于任何元素</p></blockquote><h5 id="2-focus-伪类"><a href="#2-focus-伪类" class="headerlink" title="2. : focus 伪类"></a>2. : focus 伪类</h5><p>表单中的文本字段在用户单击它时会获得焦点，然后用户才能在其中输入字符。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;</span><br></pre></td></tr></table></figure><p>上面的例子会在光标位于 input 字段中时，为该字段添加一个红色边框。</p><p><img src="/2018/09/23/CSS选择器(二)/1531732737935.png" alt="Alt text"></p><h5 id="3-target-伪类"><a href="#3-target-伪类" class="headerlink" title="3. : target 伪类"></a>3. : target 伪类</h5><p>如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标（target），可以 用:target 伪类选中它</p><p>例如<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#more_info"</span>&gt;</span>More Information<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"more_info"</span>&gt;</span>This is the information you are looking for.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用 : target之后<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#more_info</span><span class="selector-pseudo">:target</span>&#123;<span class="attribute">background</span>:<span class="number">#eee</span>;&#125;</span><br></pre></td></tr></table></figure></p><p>则用户点击链接后，h2的背景颜色将会变灰。<br><img src="/2018/09/23/CSS选择器(二)/1531733276477.png" alt="Alt text"></p><p><br></p><h4 id="（二）结构化伪类"><a href="#（二）结构化伪类" class="headerlink" title="（二）结构化伪类"></a><strong>（二）结构化伪类</strong></h4><p>结构化伪类可以根据标记的结构应用样式，比如根据某元素的父元素或前面的同胞 元素是什么。 常用的结构化伪类有这几种:</p><ul><li><strong>: first-child</strong>  代表一组同胞元素中的第一个元素</li><li><strong>: last-child</strong>  代表一组同胞元素中的最后一个元素</li><li><strong>: nth-child(n)</strong> <strong>n 表示一个数值(可用odd或even)</strong>，假如<strong>:nth-child(3)</strong>，表示选中一组同胞元素中的第三个元素</li></ul><p>例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line"><span class="selector-class">.results</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span>&#123;<span class="attribute">color</span>: blue&#125;</span><br><span class="line"><span class="selector-class">.results</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;<span class="attribute">color</span>: red&#125;</span><br><span class="line"><span class="selector-class">.results</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span>&#123;<span class="attribute">color</span>: yellow&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;ol class="results"&gt;</span><br><span class="line">&lt;li&gt;My Fast Pony&lt;/li&gt;     </span><br><span class="line">&lt;li&gt;Steady Trotter&lt;/li&gt;     </span><br><span class="line">&lt;li&gt;Slow Ol' Nag&lt;/li&gt; </span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/23/CSS选择器(二)/1531734412057.png" alt="Alt text"><br>tips：</p><ul><li>一个冒号（:）表示伪类，两个冒号（::）表示 CSS3新增的伪元素。</li><li>要习惯用双冒号代替单冒号，因为这些单冒号的伪元素终可能都会被淘汰掉。</li></ul><p><br></p><h4 id="（三）伪元素"><a href="#（三）伪元素" class="headerlink" title="（三）伪元素"></a><strong>（三）伪元素</strong></h4><p>常用伪元素</p><ul><li><p>:: first-letter</p><pre><code>可以选中段落首字符，可以用来创建首字符放大效果如：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span>&#123;<span class="attribute">font-size</span>:<span class="number">300%</span>&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>::first-line</p><pre><code>可以选中段落首行如：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span>&#123;<span class="attribute">font-variant</span>:small-caps&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>::before和::after</p><pre><code>可以在特定元素前面或后面添加特殊内容，例如：</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.age</span><span class="selector-pseudo">::before</span>&#123;<span class="attribute">content</span>: <span class="string">"Age"</span>&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.age</span><span class="selector-pseudo">::after</span>&#123;<span class="attribute">content</span>: <span class="string">"years."</span>&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p class="age"&gt;25&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/placeholder.png" alt="Alt text" data-src="./1531736054788.png" class="lazyload"></p><hr><p><br></p><h3 id="6-继承"><a href="#6-继承" class="headerlink" title="6. 继承"></a><strong>6. 继承</strong></h3><blockquote><p>在CSS中，祖先元素会向后代元素传递其CSS属性的值，这叫做CSS的继承。</p></blockquote><p>比如我们为body写一条规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>:helvetica, arial, sans-serif;&#125;</span><br></pre></td></tr></table></figure><p><strong>那么文档中的所有元素，无论层次结构多么靠下，都将继承body的样式。</strong></p><p>继承的给我们带来的效率是显而易见的。假如我们需要把网站的主字体或某个区域的主字体设置为微软雅黑，那么我们只需要在某个上层元素上指定font-family，而无须在每一个标签上都指定一次。<br>不过继承需要注意的几点：</p><ul><li><p>CSS很多属性（如文本颜色、字体、字号等）是可以继承的，也有很多属性是不能继承的，如涉及元素盒子的定位和显示方式，比如边框，内边距等，因为继承这些属性没有意义。</p></li><li><p>在使用相对字体单位时要小心，加入某个标签字体大小被设置为 80% ，他的后代字体大小也设置为 80% ，那么该后代的字体大小将会变成 64% ，即 80% 的 80% 。</p></li></ul><hr><p><br></p><h3 id="7-层叠"><a href="#7-层叠" class="headerlink" title="7. 层叠"></a><strong>7. 层叠</strong></h3><blockquote><p>层叠，就是层叠样式表中的层叠， 是一种样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性 值的多个来源，确定终使用哪个值。<br><br></p></blockquote><h4 id="样式来源"><a href="#样式来源" class="headerlink" title="样式来源"></a><strong>样式来源</strong></h4><p>一个网页的样式有多出来源，总的来说分为三种</p><ul><li><p><strong>浏览器的默认样式表</strong><br>浏览器自带的一些样式，比如h1的粗体，em的斜体，列表的项目符号和编号</p></li><li><p><strong>用户样式表</strong><br>用户(浏览网页的人)可以提供样式表，并不多见</p></li><li><p><strong>网页设计师（自己）的样式表</strong><br>即自己写的样式表，应用方式有 链接样式、嵌入样式、行内样式。</p></li></ul><p>有这么多种样式来源，浏览器如何选择按照那种样式表渲染网页呢？答案是，浏览器会按照下述顺序依次检查每个来源的样式。</p><ul><li><strong>浏览器默认样式表</strong></li><li><strong>用户样式表</strong></li><li><strong>链接式样式表</strong></li><li><strong>嵌入式样式</strong></li><li><strong>行内式样式</strong></li></ul><blockquote><p>举例个例子，假如链接样式表将 p 的字体设定为 Helvetica ，而页面中有一条嵌入样式将 p 的字体设定为微软雅黑，那么 p 最终会以微软雅黑字体显示。</p></blockquote><p>可以理解为样式来源的优先级为 <strong>行内 &gt; 嵌入 &gt; 链接 &gt; 用户 &gt; 浏览器</strong><br><br></p><h4 id="层叠规则"><a href="#层叠规则" class="headerlink" title="层叠规则"></a><strong>层叠规则</strong></h4><p><br></p><p><strong>层叠规则一：按照顺序和权重排序</strong></p><blockquote><p>浏览器一次检查 5 个样式来源，并设定匹配属性，如果匹配的属性在下一个来源也有定义，则更新该属性的值，如此循环。<br>声明也可以有权重。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:green <span class="meta">!important</span>; <span class="attribute">font-size</span>:<span class="number">12pt</span>; &#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><code>!important;</code>  用于加重声明的权重，不过比较一般少用，甚至不用。<br>上述代码的意思是，最终的颜色值还是绿色，其他来源一概不考虑，相当于一种特权。</p><p><br></p><p><strong>层叠规则二：按特指度排序</strong></p><p><strong>什么是特指度?</strong><br>特指度的意思是表示一条规则有多明确，例如：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-size</span>: <span class="number">12px</span>; &#125; </span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.largetext</span> &#123; <span class="attribute">font-size</span>:<span class="number">16px</span>; &#125;</span><br><span class="line">&lt;p class="largetext"&gt;A bit of text&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>结果 p 将会应用第二条规则，即显示 16px 的文本。因为第二条规则的选择符既有标签名又有类名，所以更加明确（特指度更高），因此第二条规则会覆盖第一条规则中的同名属性。</p><p><strong>如何计算特指度？</strong></p><p>采用  <strong>I - C- E</strong>  <code>(I指ID，C指class，E指Element)</code> 计算规则。</p><blockquote><ol><li>选择符中有一个 ID，就在 I的位置上加 1</li><li>选择符中有一个类，就在 C的位置上加 1</li><li>选择符中有一个元素（标签）名，就在 E的位置上加 1</li><li>得到一个三位数</li></ol></blockquote><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p0-0-1 特指度=1</span><br><span class="line">p.largetext 0-1-1 特指度=11     </span><br><span class="line">p#largetext 1-0-1 特指度=101</span><br><span class="line">body p#largetext 1-0-2 特指度=102</span><br><span class="line">body p#largetext ul.mylist 1-1-3 特指度=113</span><br><span class="line">body p#largetext ul.mylist li 1-1-4 特指度=114</span><br></pre></td></tr></table></figure></p><p><br></p><p> <strong>层叠规则三：顺序决定权重。</strong></p><blockquote><p>如果两条规则都影响某元素的同一个属性，而且它们的特指度也相同，则<strong>位置靠下（或后声明）的规则胜出</strong></p></blockquote><p>简单版<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531825917096.png" class="lazyload"></p><hr><h3 id="8-规则声明"><a href="#8-规则声明" class="headerlink" title="8. 规则声明"></a><strong>8. 规则声明</strong></h3><p>(待整理)</p><hr>]]></content>
      
      
        <tags>
            
            <tag> CSS设计指南笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS设计指南：CSS选择器(一)</title>
      <link href="/2018/09/02/CSS%E9%80%89%E6%8B%A9%E5%99%A8(%E4%B8%80)/"/>
      <content type="html"><![CDATA[<p>常用的css选择器(一)<br><a id="more"></a></p><h2 id="CSS选择器-一"><a href="#CSS选择器-一" class="headerlink" title="CSS选择器(一)"></a><strong>CSS选择器(一)</strong></h2><p><br></p><h3 id="1-1、上下文选择器"><a href="#1-1、上下文选择器" class="headerlink" title="1.1、上下文选择器"></a><strong>1.1、上下文选择器</strong></h3><p>上下文选择器的声明格式如下：</p><p><strong>标签1 标签2 { 声明 }</strong></p><blockquote><p>一组以空格分隔的标签名。用于选择作为指定祖先元素后代的标签。</p></blockquote><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>:bold; &#125;</span><br></pre></td></tr></table></figure><p>表示只有 <strong>article后代的所有p元素</strong> 才会应用此样式</p><p>又如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">h1</span> <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>:green; &#125;</span><br></pre></td></tr></table></figure><p>表示选中的p必须有一个祖先是h1，h1还要有个祖先是article</p><hr><p><br></p><h3 id="1-2、特殊的上下文选择器"><a href="#1-2、特殊的上下文选择器" class="headerlink" title="1.2、特殊的上下文选择器"></a><strong>1.2、特殊的上下文选择器</strong></h3><p>所用示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>An H2 Heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2 has <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>a link<span class="tag">&lt;/<span class="name">a</span>&gt;</span> in it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码的显示效果如下：</p><p><img src="/2018/09/02/CSS选择器(一)/1.png" alt="Alt text"><br><br></p><h4 id="子选择符-gt"><a href="#子选择符-gt" class="headerlink" title="子选择符 &gt;"></a><strong>子选择符 &gt;</strong></h4><p>用法：<strong>标签1 &gt; 标签2 { 声明 }</strong></p><p>下面我们给示例代码用子选择符添加样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &gt; <span class="selector-tag">h2</span> &#123; <span class="attribute">font-style</span>:italic; &#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/09/02/CSS选择器(一)/2.png" alt="示例1"></p><p>标签2必须是标签1的子元素，与常规的上下文选择符不同，这个选择符中的标签1不能是标签2的父元素之外的其他祖先元素。<br><br></p><h4 id="紧邻同胞选择符"><a href="#紧邻同胞选择符" class="headerlink" title="紧邻同胞选择符  +"></a><strong>紧邻同胞选择符  +</strong></h4><p>用法：<strong>标签1 + 标签2 { 声明 }</strong><br>例如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> + <span class="selector-tag">p</span> &#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/02/CSS选择器(一)/3.png" alt="Alt text"><br>标签2必须紧邻标签1，否则不会被选择到，比如，如果将p元素换成a元素，由于a元素没有紧邻p元素，所以a元素不会被选择到。<br><br></p><h4 id="一般同胞选择符"><a href="#一般同胞选择符" class="headerlink" title="一般同胞选择符 ~"></a><strong>一般同胞选择符 ~</strong></h4><p>用法：<strong>标签1 ~ 标签2 { 声明 }</strong> </p><p>例如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> ~ <span class="selector-tag">a</span> &#123;<span class="attribute">font-weight</span>:italic;&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/02/CSS选择器(一)/4.png" alt="Alt text"></p><p>可以看到h2的同胞元素a被选中，而p元素中的a元素却没有被选择到，也就是说一般同胞选择符只能选择到同胞元素，<strong>并且是在标签1之后的元素</strong>，两个元素之间不一定要紧邻，这也是和紧邻同胞选择符的一个区别之一<br><br></p><h4 id="通用选择符"><a href="#通用选择符" class="headerlink" title="通用选择符 *"></a><strong>通用选择符 *</strong></h4><p>用法：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123;<span class="attribute">color</span>:green&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这样会导致所有元素的文字和边框颜色变成绿色，一般在使用时都会同时使用另一个选择符</p></blockquote><p>比如:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> * &#123;<span class="attribute">color</span>:green&#125;</span><br></pre></td></tr></table></figure></p><p><strong>这样就会把p包含的所有元素的文本(不包括p本身的文本！)成绿色。</strong><br>还可以用它来构成非子选择符<br>例如:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> * <span class="selector-tag">a</span> &#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/02/CSS选择器(一)/5.png" alt="Alt text"></p><p>可以看到并没有选中section的子元素a，而是选中了section的孙子元素a。也就是说，任何section的孙子元素，而非子元素a都会被选中，与a的父元素没有关系。</p><hr><p><br></p><h3 id="2-1、类选择器"><a href="#2-1、类选择器" class="headerlink" title="2.1、类选择器"></a><strong>2.1、类选择器</strong></h3><p>所用示例代码：可以看到已经为h1和p标签添加了specialtext类</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"specialtext"</span>&gt;</span>This is a heading with the <span class="tag">&lt;<span class="name">span</span>&gt;</span>same class<span class="tag">&lt;/<span class="name">span</span>&gt;</span>as the second paragraph.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This tag has no class.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"specialtext"</span>&gt;</span> When a tag has a class attribute, you can target it <span class="tag">&lt;<span class="name">span</span>&gt;</span>regardless<span class="tag">&lt;/<span class="name">span</span>&gt;</span> of its position in the hierarchy.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="/images/placeholder.png" alt="Alt text" data-src="6.png" class="lazyload"><br><br></p><h3 id="2-2、类选择符"><a href="#2-2、类选择符" class="headerlink" title="2.2、类选择符"></a><strong>2.2、类选择符</strong></h3><p>用法：<strong>.类名 {声明}</strong></p><p>例如:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.specialtext</span> &#123; <span class="attribute">font-style</span>:italic; &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/placeholder.png" alt="Alt text" data-src="7.png" class="lazyload"></p><p>可以看到包含有specialtext类的标签全部被选中，<strong>且span元素由于我们没有为其添加样式，所以就继承了父元素的样式</strong><br><br></p><h3 id="2-3、标签带类选择符"><a href="#2-3、标签带类选择符" class="headerlink" title="2.3、标签带类选择符"></a><strong>2.3、标签带类选择符</strong></h3><p>假如只想让带有specialtext的p元素被选中，可以使用p.specialtext<br>例如:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.sepcialtext</span> &#123; <span class="attribute">font-style</span>:italic; &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/placeholder.png" alt="Alt text" data-src="8.png" class="lazyload"><br>可以看到带有specialtext的p标签被选中</p><h3 id="2-4、多类选择符"><a href="#2-4、多类选择符" class="headerlink" title="2.4、多类选择符"></a><strong>2.4、多类选择符</strong></h3><ul><li>可以给一个元素添加多个类，比如</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"specialtext featured"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>要选择同时存在这两个类名的元素，可以这样写</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.specialtext</span><span class="selector-class">.featured</span> &#123;<span class="attribute">font-size</span>:<span class="number">120%</span>;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>两个类名之间是没有空格的，若加了空格则变成了“祖先 后代”的上下文选择符</p><hr><p><br></p><h3 id="3-1、ID选择器"><a href="#3-1、ID选择器" class="headerlink" title="3.1、ID选择器"></a><strong>3.1、ID选择器</strong></h3><p>如果有一个段落像下面这样设定了 ID属性 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"specialtext"</span>&gt;</span>This is the special text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 那么，相应的 ID选择符就是这样的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#specialtext &#123;CSS 样式声明&#125;</span><br></pre></td></tr></table></figure></p><p> 或者这样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p#specialtext &#123;CSS 样式声明&#125;</span><br></pre></td></tr></table></figure><p>除此之外，ID与类的用法都一样，而且我们前面的关于类选择符的（几乎）一切，都适应于 ID选择符。</p><p><br></p><h3 id="3-2、类选择器与ID选择器的区别"><a href="#3-2、类选择器与ID选择器的区别" class="headerlink" title="3.2、类选择器与ID选择器的区别"></a>3.2、类选择器与ID选择器的区别</h3><ul><li><strong>ID选择器可用于页面导航</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#bio"</span>&gt;</span>Biography<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">"bio"</span>&gt;</span>Biography<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单击链接时，页面会向下滚动到 id 值为 bio 的 h3 元素的位置，如果链接的 href 属性里只有一个#，那么点击该链接会返回页面顶部。<br>若暂时不知道 href 应该放什么 URL，可以用 # 作为占位符，但不能留空。因为 href 属性值为空的链接的行为跟正常链接不一样。这样团队中的其他人将来可 以用中间层（比如 PHP）变量替换 # ，以便动态接收来自数据库的 URL 。</p></blockquote><ul><li><strong>什么时候用ID？</strong> </li></ul><blockquote><p>ID 是唯一的，同一个页面中每个 ID 只能用一次。<br>一般给页面中的每个顶级区域都添加一个 ID，这样就能得到非常明确的上下文。</p></blockquote><ul><li><strong>什么时候用类？</strong> </li></ul><blockquote><p>类的目的是为了标识一组具有相同特征的元素。</p></blockquote><p>在下面这个孩子名字的列表中，我想把男孩的名字变成蓝色，把女孩的名字变成粉 红色。首先，我用类在标记中标识出了性别</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"boy"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Alan<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"boy"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Andrew<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"girl"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Angela<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"boy"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Angus<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"girl"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Anne<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"girl"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Annette<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，再用 CSS为链接应用颜色： </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.boy</span> <span class="selector-tag">a</span> &#123;<span class="attribute">color</span>:<span class="number">#6CF</span>;&#125;<span class="comment">/*蓝色*/</span> </span><br><span class="line"><span class="selector-class">.girl</span> <span class="selector-tag">a</span> &#123;<span class="attribute">color</span>:<span class="number">#F9C</span>;&#125;<span class="comment">/*粉红色*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>不要乱用类</strong></li></ul><blockquote><p>不要像使用 ID 一样，每个类都指定一个不同的类名，然后再为每个类编写规则，这样你可能会给每个标签都重复写同样的样式。实际上，继承和上下文选择符能让不同的标签共享样式，从而降低你需要编写和维护的 CSS 量。</p></blockquote><hr>]]></content>
      
      
        <tags>
            
            <tag> CSS设计指南笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/26/hello-world/"/>
      <content type="html"><![CDATA[<p><img src="/2018/08/26/hello-world/banner.jpg" alt="banner"></p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br></pre></td></tr></table></figure><blockquote><p><strong>some test</strong><br><strong>中文测试</strong></p></blockquote><p><strong>some test</strong></p><h1 id="中文测试"><a href="#中文测试" class="headerlink" title="中文测试"></a><strong>中文测试</strong></h1>]]></content>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
