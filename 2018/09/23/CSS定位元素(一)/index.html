<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  CSS设计指南：定位元素(一) |   Kite Yiu </title>

 
  
    <link rel="icon" href="/images/favicon.jpg">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-nav">        
   
    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-menu">          
              
            
              <a class="header-menu-link" id="header-menu-home" href="/">首页</a>     
            
            
            
              <a class="header-menu-link" id="header-menu-archives" href="/archives">归档</a>     
            
            
            
              <a class="header-menu-link" id="header-menu-tags" href="/tags">标签</a>     
            
            
            
              <a class="header-menu-link" id="header-menu-about" href="/about">关于</a>     
            
            
            
              <a class="iconfont icon-menu-search header-menu-link" id="header-menu-search"></a>
            
                
    </div>  
    
  </nav>
</header>   

      <div class="container">       
          
          
            <section class="main">  
          

          <article class="post">
  
	<div class="post-header">

	<p class="post-title">	
		CSS设计指南：定位元素(一)
	</p>
			

	<div class="meta-info">	
	<span>
		9月 23, 2018
	</span>

	
	
		<i class="iconfont icon-words"></i>
		<span>
			5756
		</span>
	
</div>

</div> 
	 

	  <div class="post-content slideDownMin">

		

			
					<p>CSS定位元素<br><a id="more"></a></p>
<h2 id="定位元素-一"><a href="#定位元素-一" class="headerlink" title="定位元素(一)"></a>定位元素(一)</h2><p><br></p>
<h3 id="一、-理解盒子模型"><a href="#一、-理解盒子模型" class="headerlink" title="一、 理解盒子模型"></a><strong>一、 理解盒子模型</strong></h3><blockquote>
<p>每一个元素都会在页面上生成一个盒子，HTML页面实际上就是由一堆盒子组成的，默认情况下，每个盒子的边框都不可见，背景也是透明的。</p>
</blockquote>
<p>那么，盒模型有哪些属性呢，总的来说盒子的属性可分为三组：</p>
<ul>
<li><strong>border（边框）</strong> 可以设置边框的宽窄、样式和颜色</li>
<li><strong>padding（内边距）</strong>可以设置盒子内容区与边框的间距</li>
<li><strong>margin（外边距）</strong>可以设置盒子与相邻元素的间距</li>
</ul>
<p>一个盒子模型如下图所示<br><img src="/2018/09/23/CSS定位元素(一)/1531904043318.png" alt="Alt text"></p>
<p><br></p>
<h4 id="1-盒子边框（border）"><a href="#1-盒子边框（border）" class="headerlink" title="1. 盒子边框（border）"></a><strong>1. 盒子边框（border）</strong></h4><p>盒子边框有 3 个相关属性</p>
<ul>
<li><strong>boder-width</strong> 可以使用 thin、medium、thick等文本值，也可以使用除百分比和负值之外的任何绝对值。</li>
<li><strong>border-style</strong> 有none、hidden、dotted<code>(虚线)</code>、dashed、solid、double<code>（双实线）</code>、groove、ridge、inset、outset<code>（这四个是边框的内凹外凹）</code>等值。</li>
<li><strong>border-color</strong> 可以使用包括 RGB 、HSL 在内的任意颜色值和关键字。</li>
</ul>
<p>其中boder-width 、border-style 的值在不同浏览器中的显示可能有所不同。</p>
<p>默认情况下，边框的三个属性值分别为：</p>
<ul>
<li>border-width : medium</li>
<li>border-style : none</li>
<li>border-color : black</li>
</ul>
<p>因此默认情况下不会显示盒子边框，开发中我们常常会临时设定盒子的边框，为了快速把盒子边框显示出来，我们可以应用这条规则<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123; border：solid 1px ; &#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="2-盒子的内边距-padding"><a href="#2-盒子的内边距-padding" class="headerlink" title="2. 盒子的内边距(padding)"></a><strong>2. 盒子的内边距(padding)</strong></h4><p><strong>内边距是盒子内容区与盒子边框之间的距离。</strong></p>
<p>这是没有加 padding 的 p 元素<br><img src="/2018/09/23/CSS定位元素(一)/1531905405176.png" alt="Alt text"></p>
<p>当我们给他加上 10px 的 padding 之后<br><img src="/2018/09/23/CSS定位元素(一)/1531905439854.png" alt="Alt text"></p>
<blockquote>
<p>注意，由于内边距在盒子的内部，所以padding也会取得盒子的背景<br>仔细两幅图可以发现，内边距实际加在了声明的盒子的宽度之上（后面解释）</p>
</blockquote>
<p><br></p>
<h4 id="3-盒子的外边距-margin"><a href="#3-盒子的外边距-margin" class="headerlink" title="3. 盒子的外边距(margin)"></a><strong>3. 盒子的外边距(margin)</strong></h4><p>我们举三组标题和段落来说明盒子的外边距</p>
<p><img src="/2018/09/23/CSS定位元素(一)/1531905920851.png" alt="Alt text"></p>
<p>第一组和第二组都使用默认的样式，而第二组跟第一组的区别就是多了边框，对比之后，我们可以看到浏览器给标题和段落都设定了默认的 margin 样式。第三组我设定了 margin : 0 ，可以看到该组的标题和段落全部紧挨在一起。<br>因此，建议大家在写网页的时候，把这条规则作为样式表的第一条规则:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这个也叫<strong>重置CSS样式</strong>，作用是为了将浏览器给元素添加的默认样式都清除。网上有很多重置样式表（如 reset.css），还对很多元素在跨浏览器显示时的外观进行了标准化，想了解更多可以自行百度“CSS重置”</p>
</blockquote>
<p>关于外边距需要注意的几点</p>
<ul>
<li><strong>垂直外边距会叠加</strong></li>
</ul>
<p>假设有三个段落，我们均设定<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">margin-top</span>:<span class="number">50px</span>; <span class="attribute">margin-bottom</span>:<span class="number">3</span>opx;&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可能会认为每两个段落之间的间距是 50 + 30 = 80px ，这种认知错误的，实际上他们之间的间距是50px！</p>
<p><strong>像这样上下外边距相遇时，它们就会相互重叠，直至一个外边距碰到另一个元素的边框</strong>，第二段较宽的上外边距会碰到第一段的边框，<strong>也就是说，较宽的外边距决 定两个元素终离多远</strong>，这就叫做外边距的叠加。</p>
<p><strong>注意，只有垂直外边距会叠加，水平外边距并不会叠加。</strong>对于水平相邻的元素他们的水平间距是相邻外边距之和。<br><br></p>
<ul>
<li><strong>外边距的单位</strong></li>
</ul>
<blockquote>
<p>根据经验，为文本元素设置外边距时通常需要混合使用不同的单位。<br>比如说，一个段落的左、右外边距可以使用像素，以便该段文本始终与包含元素边界保持固定间 距，不受字号变大或变小的影响。而<strong>对于上、下外边距，以 em为单位则可以让段间 距随字号变化而相应增大或缩小。</strong></p>
</blockquote>
<p>比如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里使用了简写属性把上、下外边距设置为.75em，把左、右外边距设置为 30 像素*/</span> </span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">1em</span>; <span class="attribute">margin</span>:.<span class="number">75em</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，段落的垂直间距始终会保持为字体高度的四分之三（上下外边距都是.75em， 叠加后还是.75em）。如果用户增大了字号，那么不仅段落中的文本会变大，段间距也会成比例变大。这样，页面的整体布局就会比较协调一致。与此同时，使用像素 单位的左、右外边距不会改变。</p>
<hr>
<p><br></p>
<h3 id="二、-盒子的大小是如何变化的"><a href="#二、-盒子的大小是如何变化的" class="headerlink" title="二、 盒子的大小是如何变化的"></a><strong>二、 盒子的大小是如何变化的</strong></h3><p>接下来我们用两种盒子来说明盒子的具体大小是如何变化的。</p>
<ul>
<li><strong>一种是没有宽度的盒子</strong>，既没有设定 width 属性。</li>
<li><strong>另一种是带有宽度的盒子</strong>，我们设定 width ：400px<br><br></li>
</ul>
<h4 id="1-没有宽度的盒子"><a href="#1-没有宽度的盒子" class="headerlink" title="1. 没有宽度的盒子"></a><strong>1. 没有宽度的盒子</strong></h4><p>没有设定 width 属性的块级元素盒子，他的 width 属性默认值是 auto ，结果会让元素的宽度扩展到父元素同宽。<br>接下来我们给一个段落添加以下样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>:helvetica, arial, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">1em</span>; <span class="attribute">margin</span>:<span class="number">0px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#caebff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显示效果如下：<br><img src="/2018/09/23/CSS定位元素(一)/1531907921945.png" alt="Alt text"></p>
<p>可以看到，段落文本扩展到了body元素同宽。<br>接下来，我们给文本左右两侧添加内边距 padding：0 20px;<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531908385632.png" class="lazyload"></p>
<p>可以看到，添加了内边距之后，文本块的宽度会减少。<br>接下来，我们给文本左右两侧添加边框 border-width：0 6px 0 6px;<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531908426749.png" class="lazyload"></p>
<p>虽然不太明显，但实际上文本块的宽度又减少了。<br>最后，我们给左右两侧再加上外边距 margin：0 30px;<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531908625311.png" class="lazyload"></p>
<p>果不其然，文本块的宽度再一次减少</p>
<p>结论：</p>
<blockquote>
<p><strong>没有（就是没有设置 width 的）宽度的元素始终会扩展到填满其父元素的宽度为止。</strong>添加水平边框、内边距和外边距，会导致内容宽度减少，<strong>减少量等于水平边框、内边距和外边距的和</strong>。</p>
</blockquote>
<p><br></p>
<h4 id="2-带有宽度的盒子"><a href="#2-带有宽度的盒子" class="headerlink" title="2. 带有宽度的盒子"></a><strong>2. 带有宽度的盒子</strong></h4><p>我们再用和上面没有宽度的盒子一样的方法，来看看带有宽度的盒子的大小是怎样变化的。<br>给段落添加样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">ont-family</span>:helvetica, arial, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">1em</span>; <span class="attribute">margin</span>:<span class="number">0px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#caebff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">400px</span>; <span class="comment">/* 设定元素宽度为400px*/</span></span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/placeholder.png" alt="Alt text" data-src="./1531909206438.png" class="lazyload"></p>
<p>可以看到，明确设定 width 属性后，块级元素就不会再扩展到与父元素（即 body）同宽了。<br>一样的，我们添加 20px 的内边距<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1531909251064.png" class="lazyload"></p>
<p><strong>这一次，文本块的的宽度并由变化，反而使的元素比原来宽了 40px</strong><br>一样的，我们再给元素添加 6px 的边框</p>
<p><img src="/images/placeholder.png" alt="Alt text" data-src="./1531909406049.png" class="lazyload"></p>
<p>最后，添加外边距</p>
<p><img src="/images/placeholder.png" alt="Alt text" data-src="./1531909487051.png" class="lazyload"></p>
<p>为此我们可以得出，带有宽度的盒子模型大小变化的结论：</p>
<blockquote>
<p>为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展得更宽。实际上，盒子的 width 属性设定的只是盒子内容区的宽度，而非盒子要占据的水平宽度。</p>
</blockquote>
<p>总之，关于盒子大小的变化，我们需要记住一点<br><strong>设定了元素的 width 属性后，再给元素添加边框、内边距和 外边距，元素的行为与默认的 auto 状态下会有截然不同的表现。</strong> </p>
<hr>
<p><br></p>
<h3 id="三、-浮动与清除-float-clear"><a href="#三、-浮动与清除-float-clear" class="headerlink" title="三、 浮动与清除(float clear)"></a><strong>三、 浮动与清除(float clear)</strong></h3><p><br></p>
<h4 id="1-浮动"><a href="#1-浮动" class="headerlink" title="1. 浮动"></a><strong>1. 浮动</strong></h4><p><strong>浮动，意思就是把元素从常规文档流中拿出来。</strong><br>当你浮动一个元素的时候……这个元素就好像在说：‘尽量把我往上放，能放多高放多高，直到碰到某个元素的边界为止。</p>
<p>浮动元素脱离了常规文档流之后，原来紧跟其后的元素就会在空间允许的情况下，向上提升到与浮动元素平起平坐。</p>
<blockquote>
<p>CSS 设计 float 属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属性也成了<strong>创建多栏布局简单的方式</strong>。</p>
</blockquote>
<p>让我们先从文本绕排图片这个例子来认识浮动吧！</p>
<p><strong>文本绕排图片</strong></p>
<p>示例代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">		img&#123;</span></span><br><span class="line"><span class="undefined">			margin: 0 4px 4px 0;</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined">		p&#123;</span></span><br><span class="line"><span class="undefined">			margin: 0;</span></span><br><span class="line"><span class="undefined">			border: solid 1px red;</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"pic03.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>原始效果<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532009409141.png" class="lazyload"></p>
<p>可以看到处在常规文档流中的图片跟段落这两个块级元素竖直排列在一起。</p>
<p>接下来，我们要实现文字绕排文字效果了，怎么做呢？</p>
<p>就是让图片浮动起来，我们给图片添加以下样式 img { float:left }<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532009670827.png" class="lazyload"></p>
<p>解释：</p>
<blockquote>
<p>在你浮动一张图片或者其他元素时，你是在要求浏览器把它往上方推，直到它碰到父元素（也就是 body 元素）的内边界。<strong>后面的段落（带灰色边框） 不再认为浮动元素在文档流中位于它的前面了，因而它会占据父元素左上角的位置。</strong> 不过，它的内容（文本）会绕开浮动的图片。 </p>
</blockquote>
<p>注意：</p>
<blockquote>
<p>由于图片自身带有宽度，因此在浮动的时候无需设定宽度。然而在浮动非图片元素时，必须给非图片元素设定宽度，否则后果难以预料<br><br></p>
</blockquote>
<h4 id="2-围住浮动元素的三种方法"><a href="#2-围住浮动元素的三种方法" class="headerlink" title="2. 围住浮动元素的三种方法"></a><strong>2. 围住浮动元素的三种方法</strong></h4><p>上面我们讲到，当一个元素浮动后，他就脱离了文档流，因而它也不被包含在父元素之内了，因此它也可能会对布局产生破坏性的影响。那么，我们该怎么控制浮动的元素呢？</p>
<p>接下来介绍把浮动元素“控制住”的三种方法</p>
<p>示例代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">		section &#123;</span></span><br><span class="line"><span class="undefined">			margin: 0 0 10px 0;</span></span><br><span class="line"><span class="undefined">			border: solid 1px red;</span></span><br><span class="line"><span class="undefined">		&#125;	</span></span><br><span class="line"><span class="undefined">		p &#123;</span></span><br><span class="line"><span class="undefined">			margin: 0;</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined">		footer&#123;</span></span><br><span class="line"><span class="undefined">			border: solid 1px red;</span></span><br><span class="line"><span class="undefined">		&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"pic03.jpg"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>It's fun to float<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet....<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>原始效果<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532010675831.png" class="lazyload"></p>
<p>现在，一切正常，所有元素自上而下堆叠在一起，接下来，我们让图片标题位于图片右侧，该怎么做呢？从上一节我们知道，就是让图片浮动起来。给图片添加 img { float: left}</p>
<p><img src="/images/placeholder.png" alt="Alt text" data-src="./1532010876833.png" class="lazyload"></p>
<p>OK，现在图片标题以及在图片右侧啦。</p>
<p>但是我们也看到，<strong>由于图片浮动了，现在图片已经不在父元素section里面了，换句话说，图片脱离了常规文档流，这也就导致了父元素section收缩到了只包含文本高度的高度。</strong> 而且，footer元素也被提上来了，紧挨着前一个块级元素，这可不是我们想要的。</p>
<p>所以，我们必须得把浮动元素“控制住”。<br><br></p>
<h5 id="方法一：给浮动元素的父元素添加-overflow：hidden"><a href="#方法一：给浮动元素的父元素添加-overflow：hidden" class="headerlink" title="方法一：给浮动元素的父元素添加 overflow：hidden"></a><strong>方法一：给浮动元素的父元素添加 overflow：hidden</strong></h5><pre><code>overflow：hidden的用途
&gt; overflow:hidden 原本是使包含元素依然保持其设定的宽度，而超过的子内容则会被容器剪切掉（不被显示），防止包含元素被超大内容撑大。
&gt; **除此之外，overflow:hidden 还有另一个作用，即它能可靠地迫使父元素包含其浮动的子元素。**
</code></pre><p>现在我们试试给父元素 section 加上overflow : hidden<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532011483647.png" class="lazyload"></p>
<p>确认过眼神，是我们想要的效果！footer回到了我们期望的位置<br><br></p>
<h5 id="方法二：同时浮动父元素"><a href="#方法二：同时浮动父元素" class="headerlink" title="方法二：同时浮动父元素"></a><strong>方法二：同时浮动父元素</strong></h5><p>促使父元素包围其浮动子元素的方法，是也让父元素也浮动起来。<br>来，我们先试试给 section 添加float：left，让父元素浮动起来</p>
<p><img src="/images/placeholder.png" alt="Alt text" data-src="./1532011822780.png" class="lazyload"></p>
<p>结果跟我们想象中的不太一样呢，别急，回想一下我们之前的知识点，在浮动非图片元素时，我们得给他们加一个宽度对吧。那么，为什么呢？</p>
<p><strong>原因是，当我们浮动任何元素时，不管其是否有子元素，不管其子元素是否浮动，他都会紧紧地包裹住它的内容，或者是，它的子元素。</strong></p>
<p>那就好解决了，我们给 section 加一个宽度width：100%，让它和浏览器同宽就好了。<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532012223208.png" class="lazyload"></p>
<p>这效果是对了，但怎么看起来总觉得怪怪的呢？原来是footer给挤上去了！</p>
<p>再回想一下，当我们浮动了一个元素，原本紧跟其后的元素也会在空间允许的情况下不断地往上挤。因此，footer 也无一例外地努力挤到了 section 的旁边了。</p>
<p>那么，我们该怎样使得 footer 依然呆在 section 下方呢？<br>答案是给footer应用一个清除 clear：left ，这样被清除的元素就不会被提升到浮动元素的旁边。<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532012933309.png" class="lazyload"></p>
<p><br></p>
<h5 id="方法三：给父元素添加-clearfix-after-规则"><a href="#方法三：给父元素添加-clearfix-after-规则" class="headerlink" title="方法三：给父元素添加 .clearfix:after 规则"></a><strong>方法三：给父元素添加 .clearfix:after 规则</strong></h5><p>.clearfix:after 规则：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>:<span class="string">"."</span>;</span><br><span class="line">	<span class="attribute">display</span>:block;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">	<span class="attribute">visibility</span>:hidden;</span><br><span class="line">	<span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<blockquote>
<p>这个 .clearfix 规则只添加了一个清除的包含句点作为非浮动元素（必须得有内容，而句点是最小的内容）。规则中的其他声明是 为了确保这个伪元素没有高度，而且在页面上不可见。<br>使用 clear:both 意味着 section 中新增的子元素会清除左、右浮动元素（位于左、右浮 动元素下方）。这里当然可以只用 left，但 both 也适用于将来图片 float:right 的情况。</p>
</blockquote>
<p>给section元素添加类 class=”clearfix” ，我们可以得到跟上图一样的效果<br><img src="/images/placeholder.png" alt="Alt text" data-src="./1532012933309.png" class="lazyload"><br><br></p>
<h5 id="三种方法如何选择？"><a href="#三种方法如何选择？" class="headerlink" title="三种方法如何选择？"></a><strong>三种方法如何选择？</strong></h5><p>这三种方法的使用要因地制宜。</p>
<blockquote>
<p>比如，不能在下拉菜单的顶级元素上应用 overflow:hidden，否则作为其子元素的下拉菜单就不会显示了。因为下拉菜单会显示在其父元素区域的外部，而这恰恰是 overflow:hidden 所要阻止的。</p>
</blockquote>
<blockquote>
<p>再比如，不能对已经靠自动外边距居中的元素使用“浮动父元素”技术，否则它就不会再居中，而是根据浮动值浮动到左边或右边了。</p>
</blockquote>
<blockquote>
<p>推荐使用clearfix规则</p>
</blockquote>
  	
					
	  </div>     
	  

	
<div class="post-meta">
      	

      
        <i class="iconfont icon-tag"></i>     
          <a class="tag-link" href="/tags/CSS设计指南笔记/">CSS设计指南笔记</a>    
      	
</div>





<div class="post-footer">
  <div class="pf-left">
      <img class="pf-avatar lazyload" src="/images/placeholder.png" data-src="/images/header.jpg">
      <p class="pf-des">Keep code、write and speak.</p>
  </div>

  <div class="pf-right">           
      <div class="pf-links">
         
        
	
<script id="-mob-share" src="http://f1.webshare.mob.com/code/mob-share.js?appkey=21d601593a1de"></script>
	
	<span class="share-btn">
	<span class="iconfont icon-share"></span>
	</span>


	<div class="-mob-share sildeUpMin">
		   			             
            <a class="iconfont icon-share-weixin -mob-share-weixin"></a>		
     	   			             
            <a class="iconfont icon-share-weibo -mob-share-weibo"></a>		
     	   			             
            <a class="iconfont icon-share-douban -mob-share-douban"></a>		
     	   			             
            <a class="iconfont icon-share-facebook -mob-share-facebook"></a>		
     	   			             
            <a class="iconfont icon-share-twitter -mob-share-twitter"></a>		
     	   			             
            <a class="iconfont icon-share-google -mob-share-google"></a>		
     	   
	</div>	

      </div>  
    <nav class="pf-paginator">
           
        
      
        
        <a href="/2018/09/23/CSS选择器(二)/" data-hover="CSS设计指南：CSS选择器(二)"> 下一篇</a>
            
  </nav>   
  </div>
</div> 
	
	
</article>

	<div class="toc-container">
			<div class="sidebar">
			<h4 class="toc-title">目录</h4>
			<div class="toc-list">
				<ol class="toc-inner"><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#定位元素-一"><span class="toc-inner-text">定位元素(一)</span></a><ol class="toc-inner-child"><li class="toc-inner-item toc-inner-level-3"><a class="toc-inner-link" href="#一、-理解盒子模型"><span class="toc-inner-text">一、 理解盒子模型</span></a><ol class="toc-inner-child"><li class="toc-inner-item toc-inner-level-4"><a class="toc-inner-link" href="#1-盒子边框（border）"><span class="toc-inner-text">1. 盒子边框（border）</span></a></li><li class="toc-inner-item toc-inner-level-4"><a class="toc-inner-link" href="#2-盒子的内边距-padding"><span class="toc-inner-text">2. 盒子的内边距(padding)</span></a></li><li class="toc-inner-item toc-inner-level-4"><a class="toc-inner-link" href="#3-盒子的外边距-margin"><span class="toc-inner-text">3. 盒子的外边距(margin)</span></a></li></ol></li><li class="toc-inner-item toc-inner-level-3"><a class="toc-inner-link" href="#二、-盒子的大小是如何变化的"><span class="toc-inner-text">二、 盒子的大小是如何变化的</span></a><ol class="toc-inner-child"><li class="toc-inner-item toc-inner-level-4"><a class="toc-inner-link" href="#1-没有宽度的盒子"><span class="toc-inner-text">1. 没有宽度的盒子</span></a></li><li class="toc-inner-item toc-inner-level-4"><a class="toc-inner-link" href="#2-带有宽度的盒子"><span class="toc-inner-text">2. 带有宽度的盒子</span></a></li></ol></li><li class="toc-inner-item toc-inner-level-3"><a class="toc-inner-link" href="#三、-浮动与清除-float-clear"><span class="toc-inner-text">三、 浮动与清除(float clear)</span></a><ol class="toc-inner-child"><li class="toc-inner-item toc-inner-level-4"><a class="toc-inner-link" href="#1-浮动"><span class="toc-inner-text">1. 浮动</span></a></li><li class="toc-inner-item toc-inner-level-4"><a class="toc-inner-link" href="#2-围住浮动元素的三种方法"><span class="toc-inner-text">2. 围住浮动元素的三种方法</span></a><ol class="toc-inner-child"><li class="toc-inner-item toc-inner-level-5"><a class="toc-inner-link" href="#方法一：给浮动元素的父元素添加-overflow：hidden"><span class="toc-inner-text">方法一：给浮动元素的父元素添加 overflow：hidden</span></a></li><li class="toc-inner-item toc-inner-level-5"><a class="toc-inner-link" href="#方法二：同时浮动父元素"><span class="toc-inner-text">方法二：同时浮动父元素</span></a></li><li class="toc-inner-item toc-inner-level-5"><a class="toc-inner-link" href="#方法三：给父元素添加-clearfix-after-规则"><span class="toc-inner-text">方法三：给父元素添加 .clearfix:after 规则</span></a></li><li class="toc-inner-item toc-inner-level-5"><a class="toc-inner-link" href="#三种方法如何选择？"><span class="toc-inner-text">三种方法如何选择？</span></a></li></ol></li></ol></li></ol></li></ol>
			</div>
		</div>
	</div>

          </section> 
      </div>            
    
    <a id="backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">  
            <span class="search-cancel iconfont icon-cancel"></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon lazyload" src="/images/placeholder.png" data-src="/images/favicon.jpg">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
		
		2018		
	
		Kite
		<br>

		Theme By
		<a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>	
		</div>			
	 
</footer>   

  

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>